# Object Oriented Programming

Continuing with the "just like Java but better" angle, we'll now take a look at how Kotlin approaches object oriented code. While [Java is clearly an object oriented language]((https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html)), the same would be hard to say about Kotlin. We'll see later that it can fit into more than one category. But for now, let's see how it does OOP.

### Intro to classes

It only makes sense to start with the shortest possible class:

```kotlin
class Animal
```

This is what an empty class looks like in Kotlin. Classes usually have bodies indicated by curly braces `{}`, but they can be omitted if they're empty.

Classes have two kinds of constructor's let's deal with *primary constructors* first. These are declared right in the header of the function, and simply list the parameters you need to construct a class:

```kotlin
class Animal(legs: Int)
```

Adding just this parameter doesn't make much sense, we'd at the very least want to save this somewhere, so that we can work with it later. Instead of fields like in Java, Kotlin uses *properties*, which is a higher level concept. We can create a property with either the `val` or `var` keyword, just like a local variable.

```kotlin
class Animal(legs: Int) {
    val legs: Int
}
```

This code won't compile, because the `legs` property is not uninitialized. Therefore, constructing an instance of `Animal` wouldn't be safe: what would happen when someone reads the value of `legs`?

There are two ways to initialize this property within the body of the class. Either by initializing it at its declaration, or inside an *initializer block*, which is executed when the class is constructed.

```kotlin
class Animal(legs: Int) {
    val legs: Int = legs
}

class Animal(legs: Int) {
    val legs: Int

    init {
        this.legs = legs
    }
}
```

Since taking a parameter in the constructor and saving its value to a property with the same name is such a common pattern, there's shorthand for this. You can merge the declarations of the property and the constructor parameter, as well as the property's initialization by adding `val` or `var` directly in the primary constructor:

```kotlin
class Animal(val legs: Int)
```

### Inheritance

We now have our `Animal` class ready, which can serve as a base class for specific animal classes. To extend a class, we can use the following syntax:

```kotlin
class Dog : Animal(legs = 4)
```

This `Dog` class has a primary constructor that takes no parameters, and this primary constructor calls into the superclass' constructor.

>Note that even if `Animal` didn't take any parameters, you'd have to inherit from it by calling its constructor with the `: Animal()` syntax.

This code, surprisingly, doesn't compile. This is because classes in Kotlin are **final by default**, meaning that they can't be subclasses unless it's explicitly allowed, by making them `open`:

```kotlin
open class Animal(val legs: Int)
```

This design choice falls in line with one of the often cited items of the Effective Java book - *Item 19: Design and document for inheritance or else prohibit it*. Subclassing a class that was not designed to be extended can lead to a wide variety of problems, and final by default serves as a safeguard against this.

In our specific case, it also doesn't make sense to let clients create `Animal` instances directly, which we can prevent by making it `abstract`, which works essentially the same way as Java's abstract classes. Abstract classes, of course, are always `open`, because they're meant to be inherited from.

```kotlin
abstract class Animal(val legs: Int)
```

Let's add a method to `Animal`. Methods are also final by default, meaning they can't be overridden. Any method that we want to allow overrides for must be marked `open`. In the case of an `abstract` class, a method may also be marked `abstract`, if there's no implementation provided for it. This will force concrete subclasses to override it.

```kotlin
abstract class Animal(val legs: Int) {
    abstract fun speak()
}
```

While [`@Override`](https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html) used to be an optional annotation in Java, in Kotlin it's a required keyword:

```kotlin
class Dog : Animal(legs = 4) {
    override fun speak() {
        println("Woof!")
    }
}
```

### Interfaces

Kotlin also has interfaces, which are fairly straightforward. They can not hold state, i.e. they can't declare concrete properties, but they can declare properties and methods that any classes that implement the interface will have to override. They can also contain default implementations for methods.

```kotlin
interface Feedable {
    var isHungry: Boolean

    fun feed() {
        isHungry = false
    }
}

class Dog : Animal(legs = 4), Feedable {
    override var isHungry: Boolean = false

    override fun feed() {
        super.feed()
        println("Woof, woof!")
    }

    override fun speak() {
        println("Woof!")
    }
}
```

Implementing an interface has a similar syntax to extending a class, except there's no `()` after the name of the interface, as we're not calling a constructor in this case.

Inside `Dog`, we're overriding the `isHungry` property with just a regular property. We're also overriding `feed`, which is optional, but we're using the override to add some functionality to the default implementation - which we're still calling into by using `super.feed()`.

### Properties

So far, we've seen one kind of property, which could be declared either in the primary constructor, or in the body of the class.

Let's take the following example of declaring two properties and using them:

```kotlin
class Person(val name: String, var age: Int)

fun main() {
    val person = Person("Jim", 41)
    println(person.name)
    person.age = 42
}
```

It would seem like this class doesn't follow the encapsulation rules of OOP - we're accessing the data stored in the class directly. That would be the case if this was a Java class and these were fields, however, we have *properties* here. Properties are a higher level concept, which wrap a field, a getter, and a setter (only for `var`s!) into a single entity. This becomes apparent if we start using the same class from Java:

```java
public class Main {
    public static void main(String[] args) {
        Person person = new Person("Jim", 41);
        System.out.println(person.getName());
        person.setAge(42);
    }
}
```

While the getters and setters we have here are public, the fields that actually hold the data still remain private. Encapsulation checks out! This is what the one-liner `Person` class above would look like in Java:

```java
public final class Person {
   private final String name;
   private int age;

   public final String getName() {
      return this.name;
   }

   public final int getAge() {
      return this.age;
   }

   public final void setAge(int age) {
      this.age = age;
   }

   public Person(String name, int age) {
      this.name = name;
      this.age = age;
   }
}
```

##### Custom getters and setters

As you can see, by default, the getters and setters generated for a property simply read or write the property's *backing field*. We can change this behaviour by modifying the getter or setter of a property. To do this, we'll have to move our property from the primary constructor to the body of the class.

```kotlin
class Person(val name: String, age: Int) {
  var age: Int = age
      get() {
          return field
      }
      set(value) {
          field = value
      }
}
```

To start, we've reimplemented the default functionality of reading and writing the backing field, which can be accessed by the `field` keyword in both the getter and the setter.

We can customize these functions to our liking now. For example, we can lie about our age when asked, or make sure that we never get any younger:

```kotlin
var age = age
    get() = field - 5
    set(value) {
        if (value > field) {
            field = value
        }
    }
}
```

> Note the usage of an expression body with the getter, just like with any other function.

##### Computed properties

If a property has a getter (and setter, if it's a `var`) that doesn't reference its backing field, a backing field won't be generated inside the class for that property. A property like this can, for example, rely on other properties' values in its getter:

```kotlin
val isAdult: Boolean
    get() = age >= 18
```

##### Property delegation

Custom getters and setters tend to follow the same pattern over and over again. One of these patterns is *lazy initialization*, computing a value only when it's first needed, and then storing it for later use.

Here's an example of `pi` being computed only if it hasn't been computed yet, and otherwise simply returned when the getter is invoked:

```kotlin
private var pi_: Double? = null
val pi: Double
    get() {
        if (pi_ == null) {
            // Some expensive computation
            val sum = (1..50_000).sumByDouble { 1.0 / (it * it) }
            pi_ = sqrt(sum * 6.0)
        }
        return pi_!!
    }
```

>This property uses another property to store its data instead of its own backing field - a *backing property* - because the type of the property and the data it needs to store is different. This is due to nullability concerns, which will be covered in the next lecture.

If we were to now write code that lazily computes `e` (Euler's constant), we'd end up writing a lot of the same code as before. Two properties, one of them `null` initially, a custom getter that performs a `null` check and executes the initialization code if needed, and finally, a `return` statement.

```kotlin
private var e_: Double? = null
val e: Double
    get() {
        if (e_ == null) {
            // Again, complex, expensive computation
            val sum = (0..20).sumByDouble { 1.0 / (1..it).fold(1, { a, x -> a * x }) }
            e_ = sum
        }
        return e_!!
  }
```

A feature called *property delegation* comes to the rescue here, which allows us to extract our getter (and setter) logic into a class, and make it reusable. We'll look at how we can do this on our own later down the line, but let's take a look at what delegates the standard library provides for us, starting with [`lazy`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html). You can delegate a property using the `by` keyword:

```kotlin
val pi: Double by lazy {
    val sum = (1..50_000).sumByDouble { 1.0 / (it * it) }
    sqrt(sum * 6.0)
}
```

The logic performing the lazy initialization is now all gone from our own code, and all we have to focus on is the initialization logic itself! `lazy` is also thread-safe by default, which you can disable with an additional parameter, if you don't need the safety and want better performance:

```kotlin
lazy(mode = LazyThreadSafetyMode.NONE) { ... }
```

Another common pattern is running code when the value of a property changes. [`Delegates.observable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html) serves this purpose. Let's use it to log changes to a property's value:

```kotlin
var name: String by Delegates.observable("Megan") { property, oldValue, newValue ->
    println("Name changed from $oldValue to $newValue")
}
```

Finally, there's [`Delegates.vetoable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable.html), which lets you veto a new value, if it doesn't pass whatever criteria you have for it. Here you have to return a `Boolean` value, which will prevent the new value from being set, if it's `false`. Let's perform aging validation again:

```kotlin
var age: Int by Delegates.vetoable(30) { property, oldValue, newValue ->
    newValue > oldValue
}
```

### Constructors

TODO reference article, basically...

### Data classes

article copypaste

### Objects

top level, nested, companion, syntax specilities, foreshadowing to Java interop lesson

##### Constants (back to properties for a sec)

TODO

### Enums

### Visibility

lits of modifiers, public by default

### Class delegation

effective Java reference

### Types

typealiases, typchecks and conversions