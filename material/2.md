# Object Oriented Programming

Continuing with the "just like Java but better" angle, we'll now take a look at how Kotlin approaches object oriented code. While [Java is clearly and strictly an object oriented language](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html), the same would be hard to say about Kotlin with confidence. We'll see later that it supports more than just this one paradigm. But for now, let's see how it does OOP.

### Intro to classes

It only makes sense to start with the shortest possible class:

```kotlin
class Person
```

This is what an empty class looks like in Kotlin. Classes usually have bodies indicated by curly braces `{}`, but they can be omitted if they're empty.

Classes have two kinds of constructor's - we'll deal with *primary constructors* first. These are declared right in the header of the class, and simply list the parameters you need to construct a class:

```kotlin
class Person(name: String, age: Int)
```

Just adding these parameters doesn't make much sense, we'd at the very least want to save them somewhere, so that we can work with them later. In Java, we'd use fields for this. In Kotlin we'll use *properties*, which is a higher level concept. We can create a property with either the `val` or `var` keyword, just like a local variable.

```kotlin
class Person(name: String, age: Int) {
    val name: String
    var age: Int
}
```

This code won't compile yet, as our properties are not initialized. Therefore, constructing an instance of `Person` wouldn't be safe: what would happen when someone reads the value of `name` or `age`?

There are two ways to initialize this property within the body of the class. Either by initializing it at its declaration, or inside an *initializer block*, which is executed when the class is constructed:

```kotlin
class Person(name: String, age: Int) {
    val name: String = name
    var age: Int

    init {
        this.age = age
    }
}
```

Since taking a parameter in the constructor and saving its value to a property with the same name is such a common pattern, there's shorthand for this. You can merge the declarations of the property and the constructor parameter, as well as the property's initialization by adding `val` or `var` directly in the primary constructor:

```kotlin
class Person(val name: String, var age: Int)
```

### Properties

So far, we've seen one kind of property, which could be declared either in the primary constructor, or in the body of the class.

Let's take the following example of using the class that we've created:

```kotlin
fun main() {
    val person = Person("Mandy", 41)
    println(person.name)
    person.age = 42
}
```

It would seem like this class doesn't follow the encapsulation rules of OOP - we're accessing the data stored in the class directly. That would be the case if this was a Java class and these were fields, however, we have *properties* here. Properties are a higher level concept, which encompass a field, a getter, and a setter (only for `var`s!) into a single entity. This becomes apparent if we start using the same class from Java:

```java
public class Main {
    public static void main(String[] args) {
        Person person = new Person("Mandy", 41);
        System.out.println(person.getName());
        person.setAge(42);
    }
}
```

While the getters and setters we have here are public, the fields that actually hold the data still remain private. Encapsulation checks out!

We can even jump into the Kotlin decompiler that ships with the Kotlin IntelliJ plugin and view a decompiled version of the class, which shows us an approximation of what the one-liner `Person` class above would look like in Java:

```java
public final class Person {
   private final String name;
   private int age;

   public final String getName() {
      return this.name;
   }

   public final int getAge() {
      return this.age;
   }

   public final void setAge(int age) {
      this.age = age;
   }

   public Person(String name, int age) {
      this.name = name;
      this.age = age;
   }
}
```

##### Custom getters and setters

As you can see, by default, the getters and setters generated for a property simply read or write the property's *backing field*. We can change this behaviour by modifying the getter or setter of a property. To do this, we'll have to move our property from the primary constructor to the body of the class - the primary constructor is only for simple, straightforward properties.

```kotlin
class Person(val name: String, age: Int) {
  var age: Int = age
      get() {
          return field
      }
      set(value) {
          field = value
      }
}
```

To start, we've reimplemented the default functionality of reading and writing the backing field, which can be accessed by the `field` keyword in both the getter and the setter. The getter can take no parameter, and the setter takes a single parameter, usually named `value`.

We can customize these functions to our liking now. For example, we can always lie about our age when asked, or make sure that we never get any younger than our current age:

```kotlin
var age = age
    get() = field - 5
    set(value) {
        if (value > field) {
            field = value
        }
    }
}
```

> Note the usage of an expression body with the getter, just like with any other function.

Notice how Kotlin's type inference is at work here. The type of the property is not specified anywhere in its now lengthy declaration, it's inferred from the constructor property that it's initialized from. The full syntax with very explicit typing would look like this:

```kotlin
var age: Int = age
    get(): Int = field - 5
    set(value: Int) {
        if (value > field) {
            field = value
        }
    }
```

This contains a lot of unnecessary typing, but typing at least the property itself on the first line may be a good idea - doing so prevents it from accidentally changing its type when the constructor parameter's type changes.

It's also important to note that even though we're now writing a getter an setter in our class' implementation, the usage remains the same as before. We can read and write our property by just referencing its name directly:

```kotlin
val person = Person("Dave", 38)
println(person.age) // 33
person.age = 20
println(person.age) // 33
```

However we implement a property, whether we rely on the default implementation or do it ourselves, they're always encapsulated, and use accessor functions under the hood. This helps us with [maintaining the APIs](https://zsmb.co/maintaining-compatibility-in-kotlin-libraries/) of classes, while allowing is to change their internals in a broad variety of ways.

##### Property delegation

Custom getters and setters tend to follow the same patterns over and over again. One of these popular patterns is *lazy initialization*, computing a value only when it's first needed, and then storing it for later use.

Here's an example of  a `pi` property which is computed only if it hasn't been accessed yet, and otherwise simply returned when the getter is invoked:

```kotlin
private var pi_: Double? = null
val pi: Double
    get() {
        if (pi_ == null) {
            // Some expensive computation
            val sum = (1..50_000).sumByDouble { 1.0 / (it * it) }
            pi_ = sqrt(sum * 6.0)
        }
        return pi_!!
    }
```

>This property uses another property to store its data instead of its own backing field - a *backing property* - because the types of the property and the data it needs to store are different. This is due to nullability concerns, which will be covered in the next lecture.

>The computation itself uses some advanced features that we didn't cover yet, but you can attempt to figure out how it works!

If we were to now write code that lazily computes `e` (Euler's constant), we'd end up writing a lot of the same code as before. Two properties, one of them `null` initially, and a custom getter that performs a `null` check and executes the initialization code if needed, and finally, a `return` statement.

```kotlin
private var e_: Double? = null
val e: Double
    get() {
        if (e_ == null) {
            // Again, complex, expensive computation
            val sum = (0..20).sumByDouble { 1.0 / (1..it).fold(1, { a, x -> a * x }) }
            e_ = sum
        }
        return e_!!
  }
```

A feature called *property delegation* comes to the rescue here, which allows us to extract our getter (and setter) logic into a class, and make it reusable. We'll look at how we can do this on our own later down the line, but let's take a look at what delegates the standard library provides for us, starting with [`lazy`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html). You can delegate a property using the `by` keyword, and create a lazy property with `lazy {}`:

```kotlin
val pi: Double by lazy {
    val sum = (1..50_000).sumByDouble { 1.0 / (it * it) }
    sqrt(sum * 6.0)
}
```

The logic performing the lazy initialization is now gone from our own code, and all we have to focus on is the initialization logic itself! It's worth mentioning that `lazy` is also thread-safe by default, which you can disable with an additional parameter, if you don't need the safety and want better performance:

```kotlin
lazy(mode = LazyThreadSafetyMode.NONE) { ... }
```

Another common pattern is running code whenever the value of a property changes. [`Delegates.observable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html) serves this purpose. Let's use it to ["log"](https://stackoverflow.com/questions/31869391/what-is-the-difference-between-java-logger-and-system-out-println) changes to a property's value:

```kotlin
var name: String by Delegates.observable("Megan") { property, oldValue, newValue ->
    println("Name changed from $oldValue to $newValue")
}
```

Finally, there's [`Delegates.vetoable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable.html), which lets you veto a new value, if it doesn't pass whatever criteria you define for it. Here you have to return a `Boolean` value, which when `false` will prevent the new value from being set. Let's perform the previously used aging validation again:

```kotlin
var age: Int by Delegates.vetoable(0) { property, oldValue, newValue ->
    newValue > oldValue
}
```

### Constructors

>This section was adapted from a blog post that originally appeared on [zsmb.co](https://zsmb.co/primaries-matter-a-discussion-of-constructors/).

Primary constructors play a fundamental role in Kotlin classes. Let's take a close look at them, understand what exactly is part of a primary constructor, what makes this constructor special, and what the alternatives are.

##### Back to Java for a moment

In Java, class creation isn't exactly strict. The language lets you leave variables uninitialized without any complaints. Take this class for example:

```java
public class Car {
    String model;
    int year;
    double miles;
}
```

It has three fields, and an implicit constructor with no parameters. When you call its constructor with `new Car()`, all of these fields will be initialized to implicit default values: `null`, `0`, and `0.0`, respectively. In general, primitive types are initialized to some resemblance of `0`, while reference types are initialized to `null`.

##### Kotlin's safety guarantees

In contrast, Kotlin is very strict about creating instances. We've seen that a class like this does not compile in Kotlin, because initializing each property when an instance is created is mandatory.

```kotlin
class Car {
    val model: String
    val year: Int
    var miles: Double
}
```

>*e: Property must be initialized or be abstract*

*This forces you to explicitly initialize every value in one way or another, and guarantees that your properties won't have implicit values stored in them.* Whenever you read a property, you'll get a value out of it that *you* put there.

##### The primary constructor

We've also seen already that there are two ways to initialize these properties. You can initialize them inline at their declarations, or in one or more initializer (`init`) blocks. 

```kotlin
class Car(model: String, year: Int) {
    val model: String = model
    val year: Int
    var miles: Double = 0.0

    init {
        this.year = year
    }
}
```

These two kinds of initializations are performed from top to bottom, in order. In the example, `model` and `miles` would be initialized first, and then finally `year` would get its value. *Any parameters that the primary constructor takes may be used for these initializations*.

The IDE warnings at this point will suggest for us to [join the declaration and assignment](https://stackoverflow.com/q/42600368/4465208) of `year`, and to move both `model` and `year` into the primary constructor. Properties in the primary constructor will be initialized before anything in the body of the class, and again, they'll be initialized in order.

```kotlin
class Car(val model: String, val year: Int) {
    var miles: Double = 0.0
}
```

Previously initialized variables will also be in scope during initialization if you want to rely on their values:

```kotlin
class Car(val model: String, val year: Int) {
    var miles: Double = 0.0

    val age: Int

    init {
        age = getCurrentYear() - year
    }

    val description: String = "$model ($age years, $miles miles)"
}
```

We can only initialize `description` this way after `age` has been initialized. If we 
placed it before the `init` block, we'd again see an error:
  
>*e: Variable 'age' must be initialized*

##### A look under the hood

If we decompile the bytecode produced for this class using the decompiler of the Kotlin IDEA plugin, we'll see this corresponding Java source (comments added):

```java
public final class Car {
    private double miles;
    private final int age;
    private final String description;
    private final String model;
    private final int year;

    // Getters & setters ...

    public Car(String model, int year) {
        // Properties in the primary constructor
        this.model = model;
        this.year = year;

        // Initialization at the declaration
        // (This is actually optimized away if we init to 0)
        this.miles = 0.0D;

        // init block
        this.age = Utils.getCurrentYear() - this.year;

        // Initialization at the declaration
        this.description = this.model + " (" + this.age + " years, " + this.miles + " miles)";
    }
}
```

This shows us how all the different kinds of initializations end up in the body of a single constructor together.

##### Initialization rules, recap

To review, the initialization order:

- Properties in the primary constructor, in declaration order.
- Initializations at property declarations and in initializer blocks, interleaved, in the order that they appear in the class body.

Essentially, you can read the initialization statements in the class top to bottom, and that's what you'll get in the "body" of the primary constructor.

In each of these initializations, you can use the values of:

- Constructor parameters, whether or not they're stored in properties.
- Previously initialized *(not just declared!)* properties.

*Due to these restrictions and safety guarantees, classes created via the primary constructor will always be in a valid state.*

![A representation of our single, primary constructor, which is in a valid state.](./images/2_primary.png)

##### Secondary constructors

Of course, there are cases when you want to create class instances with different sets of parameters, which normally requires multiple constructors. Kotlin's [default parameter values](https://kotlinlang.org/docs/reference/functions.html#default-arguments) make this possible to some extent while still keeping just a primary constructor. However, if you need a constructor that has entirely new parameters or parameters with entirely new types, you'll need a *secondary constructor*.

For our example, let's say we need to be able to create cars with a model, year, and mileage, all provided as strings. Our primary constructor can't accommodate these parameters, so it's time to write a new one. This could be our first attempt:

```kotlin
constructor(
        model: String,
        year: String,
        mileage: String
) {
    this.model = model
    this.year = year.toInt()
    this.miles = mileage.toDouble()
}
```

This code would fail at constructing a valid `Car` instance, and so it doesn't compile (though it certainly would in Java). For example, it doesn't set the `age` and `description` properties of the instance, which we expect to be initialized by every constructor.

>We also get an error for trying to set `year` and `miles` here: *Val cannot be reassigned*. As a `val` can only be initialized once, that one initialization will always have to happen in the primary constructor.

![A secondary constructor that doesn't call the primary constructor is invalid.](./images/2_primary_and_invalid_secondary.png)

The fix, and the rule for secondary constructors is simple: it has to first call the primary constructor, and only after that can it perform further initialization on the instance that was created. *After the primary constructor is called by the secondary constructor, the instance is already in a guaranteed valid state*, so it's safe to operate on it in the body of the secondary constructor.

Let's fix our constructor to invoke the primary constructor first:

```kotlin
constructor(
        model: String,
        year: String,
        mileage: String
): this(model, year.toInt()) {
    miles = mileage.toDouble()
}
```

![A secondary constructor that calls the primary constructor directly.](./images/2_primary_and_valid_secondary.png)

The call to the primary constructor doesn't have to be direct, it can also happen indirectly through calling another secondary constructor, but this chain eventually has to end in a call to a primary constructor.

Here's an example of yet another new constructor, which calls the previous secondary constructor:

```kotlin
constructor(data: Array<String>) : this(
        model = data[1],
        year = data[3],
        mileage = data[7]
)
```

![A secondary constructor that calls the primary constructor indirectly.](./images/2_primary_and_valid_secondaries.png)

What we really have here is a graph of the various constructors in our class calling each other.

- A primary constructor is valid if it initializes all properties. 
- A secondary constructor is valid if it eventually calls the primary constructor, i.e. if there's a directed path to the node representing the primary constructor from the node of the secondary constructor.
  - This also means no cycles within secondary constructor nodes, and no disconnected nodes.
- The entire class is valid if all constructors are valid.

![A graph of constructors.](./images/2_graph.png)

##### Without primaries

One last approach you can take is to not use a primary constructor at all. This is useful when trying to convert the inputs of the various constructors into one canonical form is just too cumbersome to do.

In this case, the strict initialization requirements will apply to the secondary constructors. If you declare a property that's not initialized at its declaration or in an initializer block, it must be initialized by *all* secondary constructors.

You may still use those two ways of initializing properties that were used in the primary constructor before, and these will run before each of your secondary constructor's bodies. This means that any initialization that makes use of constructor parameters will now have to be placed inside the secondary constructors, and potentially needs to be duplicated. This is the downside of not using a primary constructor: losing its superpowers of accessing parameters in the class body.

For example, you can no longer initialize `age` this way, since the initialization of `year` will only happen after the initializer block has run, in the body of each secondary constructor:

```kotlin
class Car {
    val model: String
    val year: Int
    var miles: Double = 0.0
    val age: Int

    init {
        age = getCurrentYear() - year
    }

    constructor(
            model: String,
            year: Int
    ) {
        this.model = model
        this.year = year
    }

    constructor(
            model: String,
            year: String,
            mileage: String
    ) {
        this.model = model
        this.year = year.toInt()
        this.miles = mileage.toDouble()
    }
}
```

Thankfully, this results in a compile time check, and an error:

>*e: Variable 'year' must be initialized*

One solution for this would be to move the `age` initialization into each constructor separately:

```kotlin
constructor(
        model: String,
        year: Int
) {
    this.model = model
    this.year = year
    this.age = getCurrentYear() - year
}

constructor(
        model: String,
        year: String,
        mileage: String
) {
    this.model = model
    this.year = year.toInt()
    this.miles = mileage.toDouble()
    this.age = getCurrentYear() - year
}
```

In certain cases, you can get rid of this kind of duplication by calling one secondary constructor from another. In this case, the first constructor will guarantee that the class is already fully initialized, and the second one has no strict initialization requirements imposed on it.

```kotlin
constructor(
        model: String,
        year: Int
) {
    this.model = model
    this.year = year
    age = getCurrentYear() - year
}

constructor(
        model: String,
        year: String,
        mileage: String
) : this(model, year.toInt()) {
    miles = mileage.toDouble()
}
```

![A secondary constructor delegating to another.](./images/2_secondary_delegation.png)

Visually, we've now lost the single node in the graph that we can delegate safe initialization to. Therefore, each secondary constructor has to perform correct initialization on its own merits, or call another, already known to be correct secondary constructor. We now have a forest instead of a tree.

![A forest of secondary constructors](./images/2_secondary_constructor_forest.png)

### Data classes

One of the very frequently advertised features of Kotlin is *data classes*. To create a data class, simply add the `data` keyword to a class. Getting back to our `Person` example:

```kotlin
data class Person(val name: String, var age: Int)
```

Adding this keyword adds some new functionality to this class, in the form of automatically generated methods. The first three of these are the `equals`, `hashCode`, and `toString` methods, which you already know from Java.

>In Java, these methods are present on the `Object` type, which every class implicitly has as a supertype. In Kotlin, the type in the same role is called [`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html), and maps exactly to `java.lang.Object` when you're running Kotlin on the JVM.

The generated `equals` and `hashCode` methods will always consider all properties that are in the primary constructor, and only those. If you need different behaviour, you’ll need to write these methods yourself. This might be a case where you’re better off without a data class.

The generated `toString` method will give you a nicely formatted string that contains the name of the class, as well as the current values of its primary constructor properties:

```kotlin
val emma = Person("Emma", 19)
println(emma) // Person(name=Emma, age=19)
```

There are also methods generated that are only useful for Kotlin users. One of these is the `component1`, `component2`, etc. method that can be used with [destructuring declarations](https://kotlinlang.org/docs/reference/multi-declarations.html), a feature that allows you to decompose an object into its components by declaring and initializing multiple variables at the same time with an assignment like this:

```kotlin
val (name, age) = emma
println(name) // Emma
```

Note that destructuring works in a positional way, and that these variables can have arbitrary names. For example, swapping the names of these two variables will lead to very unexpected results:

```kotlin
val (age, name) = emma
println(name) // 19
```

Finally, the last generated method for data classes is `copy`, which allows you to, well, make a copy of your current instance.

```kotlin
val clone = emma.copy()
println(clone) // Person(name=Emma, age=19)
```

Its real power lies in the fact that it actually has as many parameters as the class does in its primary constructor - they just all default to taking the value of the original instance. This means that you can choose to change them one by one, using named parameters for example:

```kotlin
val olderEmma = emma.copy(age = 26)
println(olderEmma) // Person(name=Emma, age=26)
```

We've provided only the `age` parameter, so any other properties will take their values from the original instance.

The `copy` method comes in especially handy when using it on completely immutable data classes, which only have `val` properties. Since you can't change these, you have to create new instances whenever you need to represent new data, and this can get very tedious when you have to just copy each property. The `copy` method does this for you, allowing you to only change what you want to change for the new instance, easily.

>Notice how this is part of Kotlin's general push to prefer immutability. The less mutable state a class holds, the easier it is to reason about how it will behave at any given point in time. Immutability also has huge advantages in multi-threaded environments. You don't have to synchronize accesses to immutable objects, as they never change! So whether it's a local variable or a property, always go with a `val` first.

Data classes do have some requirements:
- Their primary constructor can't be empty, it needs to contain at least one property.
- All of the primary constructor parameters need to be properties, either `val` or `var`.
- Inheritance is also restricted: most importantly, they can not be inherited from.

The last point here is especially important, and can be quite restrictive in some cases. Remember that regular Kotlin classes are already very concise and powerful if you just need them to hold a couple values as properties. [Not everything has to be a data class.](https://zsmb.co/data-classes-arent-that-magical/)

>Hint: The generated code for data classes is a very interesting thing to look at with a decompiler!

### Objects

An `object` is a construct much like a class in Kotlin. It's essentially a very concise way to declare a singleton:

```kotlin
object Logger {
    var isEnabled = true
    
    fun log(message: String) {
        if (isEnabled) {
            println(message)
        }
    }
}
```

An `object` can not have a constructor, and its single instance can be accessed simply by its name:

```kotlin
Logger.log("Hello world") // Hello world
Logger.isEnabled = false
Logger.log("Oh no, where's my log") //
```

Objects may be declared inside classes. In this case, they can access the internals of the class that they're nested in, and they can be accessed with the following syntax:

```kotlin
class Document {
    object Counter {
        var count: Int = 0
    }

    val id = Counter.count++
}

fun main() {
    repeat(5) {
        Document()
    }
    println(Document.Counter.count) // 5
}
```

>[`repeat`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html) is a simple way to execute the piece of code a given number of times.

How would you add a counter like this in Java? You would simply use a static variable inside the class. Kotlin doesn't have static members, neither properties nor functions. However, if you mark a nested `object` inside the class inside as the class' *companion object*, you'll get the following familiar syntax for accessing it:

```kotlin
class Document {
    companion object Counter {
        var count: Int = 0
    }

    val id = Counter.count++
}

println(Document.count)
```

What happens in this case is that writing down the class' name -`Document` in this example - will give you the reference to the companion object immediately. You can confirm this easily, with this slightly interesting line of code:

```kotlin
val counter: Document.Counter = Document
```

Naturally, classes can only have one companion object. This object doesn't have to have an explicit name, in this case, it will be named `Companion` implicitly:

```kotlin
class Document {
    companion object {
        var count: Int = 0
    }

    val id = count++
}

val counter: Document.Companion = Document
println(Document.count) // 5
```

As far as Kotlin syntax is concerned, this is as good as having static variables and functions - you simply place these inside a companion object. However, these things are still members in an inner class of `Document`, which we're then using just a single instance of. They're not *really* static. This can cause issues with certain frameworks that work with statics, and the syntax for Java clients isn't completely smooth either:

```java
Document.Companion.getCount();
```

We'll discuss ways to ensure that Java clients get the best experience when calling into Kotlin code in a later lecture.

###  Nested classes

A very quick word about nested classes. They work similarly to the ones in Java, with one big difference: they don't hold a reference to the outer class by default. This helps avoid accidentally capturing references to outer classes, which can lead to memory leaks. In Java, this would be achieved by adding the `static` keyword in front of the nested class.

```kotlin
class Outer {
    var outerValue = 0
    
    class Inner {
        init {
            println(outerValue)
                 // ^ Unresolved reference: outerValue
        }
    }
}
```

To get an implicit reference to the outer class stored in the nested class, use the `inner` keyword:

```kotlin
class Outer {
    var outerValue = 0

    inner class Inner {
        init {
            println(outerValue) // 0
        }
    }
}
```

### Inheritance

We now have our `Animal` class ready, which can serve as a base class for specific animal classes. To extend a class, we can use the following syntax:

```kotlin
class Dog : Animal(legs = 4)
```

This `Dog` class has a primary constructor that takes no parameters, and this primary constructor calls into the superclass' constructor.

>Note that even if `Animal` didn't take any parameters, you'd have to inherit from it by calling its constructor with the `: Animal()` syntax.

This code, surprisingly, doesn't compile. This is because classes in Kotlin are **final by default**, meaning that they can't be inherited from unless that's explicitly allowed, by making them `open`:

```kotlin
open class Animal(val legs: Int)
```

This design choice falls in line with one of the often cited items of the [Effective Java](https://www.amazon.co.uk/Effective-Java-Joshua-Bloch-ebook/dp/B078H61SCH/) book - *Item 19: Design and document for inheritance or else prohibit it*. Extending a class that was not designed with inheritance in mind can lead to a wide variety of problems, and final by default serves as a safeguard against this.

In our specific case, it also doesn't make sense to let clients create `Animal` instances directly, which we can prevent by making this base class `abstract`, which works the same way as Java's abstract classes. Abstract classes, of course, are always `open`, because they're meant to be inherited from.

```kotlin
abstract class Animal(val legs: Int)
```

Let's add a method to `Animal`. Methods are also final by default, meaning they can't be overridden. Any method that we want to allow overrides for must be marked `open`. In the case of an `abstract` class, a method may also be marked `abstract`, if there's no default implementation provided for it. This will force concrete subclasses to override it.

```kotlin
abstract class Animal(val legs: Int) {
    abstract fun speak()
}
```

While [`@Override`](https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html) used to be an optional annotation in Java, in Kotlin it's a required keyword:

```kotlin
class Dog : Animal(legs = 4) {
    override fun speak() {
        println("Woof!")
    }
}
```

### Interfaces

Kotlin also has interfaces, which are fairly straightforward. They can not hold state, i.e. they can't declare concrete properties, but they can declare properties and methods that any classes that implement the interface will have to override. They can also contain default implementations for methods.

TODO

##### Computed properties

If a property has a getter (and setter, if it's a `var`) that doesn't reference its backing field, a backing field won't be generated inside the class for that property. A property like this can, for example, rely on other properties' values in its getter:

```kotlin
val isAdult: Boolean
    get() = age >= 18
```

Since these properties don't require a backing field, they can be present in interfaces. Really, they're just a function with a default implementation!

### Sealed classes

TODO

### Types

TODO typechecks and conversions, combine `when` with sealed classes`, hint that there'll be even more ways in the nullability lesson

### Class delegation

TODO effective Java reference

### Enums

Enums are classes in Kotlin, which only have a small set of instances. A very simple enum would look like this:

```kotlin
enum class Sizes {
    S, M, L
} 
```

Enums may also have properties and methods just like any regular class, which can be implemented once for each of them, or be abstract and implemented by each value separately:

```kotlin
enum class MenuItem(val price: Double) {
    Hamburger(4.65),
    Fries(3.50),
    Coke(2.50) {
        override fun purchase() {
            super.purchase()
            println("It's a coke!")
        }
    };
    
    open fun purchase() {
        println("Spending $price")
    }
}

```

>The semicolon separating the list of instances from the enum's methods is the only required semicolon in the Kotlin language.

### Visibility

Kotlin has similar [visibility modifiers](https://kotlinlang.org/docs/reference/visibility-modifiers.html) to Java, with a few significant changes. These modifiers can be applied to declarations of various types: classes, objects, properties, and so on.

- `public` declarations are accessible from anywhere. *This is the default visibility in Kotlin*, its implicit, and there is no "package" visibility.
- `private` declarations in classes are only accessible within the same class, top level `private` declarations are only accessible in the same file.
- `protected` declarations are only accessible in the containing class or its subclasses. They are *not* accessible from code in the same package, like in Java.
- `internal` declarations are accessible within the same compilation unit, for example, the same Gradle module. This is especially useful for keeping library internals private from clients.

Some interesting uses of visibility modifiers would be applying them to constructors, or auto-generated getters/setters:

```kotlin
class SecretValue internal constructor(initialValue: Int) {
    var state: Int = initialValue
        private set
}
```

This class cannot be instantiated from another module due to the limited visibility of its constructor, and while its `state` property is a `var`, its setter will not be visible externally, essentially making it a `val` to the outside world.