# Introduction

Programming languages. There's a lot of them, and it could be argued that all of them have their uses, their pros and cons. ~~Well, perhaps all but JavaScript.~~

There are things however that are generally considered positive attributes for languages, and many modern languages are converging in terms of these attributes. During this course, we'll be studying Kotlin, which is an example of a modern, well-rounded language, but you'll see many similar features in other languages such as Swift, C#, or Groovy, just to name a few examples.

The language's creators proudly admit that almost none of the features in Kotlin have been invented from scratch. We all stand on the shoulders of giants, there's nothing new under the sun, and [everything is a remix](https://www.youtube.com/watch?v=nJPERZDfyWc). Great creations always take existing pieces of work, copy, transform, and combine them into something new. Creating a language is no different from your everyday coding in this regard.

What still makes Kotlin unique is how well the features that _were_ picked fit together, and what features were omitted on purpose, because they would have broken the language's consistency, or go against its aims.

So what are some of these desired attributes that Kotlin aims to achieve?

{ SOURCE: https://www.youtube.com/watch?v=PsaFVLr8t4E }

- **Conciseness**, i.e. less code for expressing the same ideas. Not for the sake of conciseness itself, but to improve **readability** compared to more verbose languages. Not having to write boilerplate code makes coding faster, and more importantly, not having that boilerplate in your codebase makes navigating through and reading your existing code a lot easier.
- **Safety** means that your program misbehaves as little as possible. There's various ways to achieve such safety at the language level. Kotlin does this by having a strong, static type system, which reveals most mistakes at compile time (and often even at edit time), rather than letting your code fail at runtime.
- **Interoperability** is one of the fundemental aims of Kotlin. It runs on multiple platforms, and on each of them it cooperates with the native environment and libraries as much as possible.
- **Pragmatism** is a way of saying that Kotlin is not an academic language. It's meant for use in real industrial settings, and to solve real, practical problems.
- **Tooling** is something you might overlook at first when evaluating languages, but it's something that can make a good language a true pleasure to use. While there are still proud Vim warriors out there, most developers are used to using rich IDEs for their coding needs, and Kotlin's tooling comes directly from its creators.

This brings us to Kotlin's origin story.

# History

JetBrains, the company behind the IntelliJ platform (and all the IDEs that are built on it) has been developing their products in Java for a decade by 2010. During this time, they've built up immense experience in creating tooling for programming languages, and they also got very familiar with Java's pros and cons.

It was at this time that they started looking for a new language for their own development needs that was better than Java. They've evaluated the existing JVM languages, but they didn't find one at the time that would've satisfied their needs. (The closest candidate was Scala, but it was notoriously difficult to make tooling for, and it suffered from lengthy compilation times.) So they've done what anyone else would've done at this point - created their own.

This is not generally a good idea for just anyone - like writing your own date library or rolling your own crypto. But with the tooling and language expertise of JetBrains, as well as their good market position, they've deemed it a viable project, and got started on it.

Some highlights of the language's development:

- 2010: internal development started under the name "JetLang".
- July 2011: announced to the general public as Project Kotlin.
- February 2016: Kotlin 1.0, the first stable release.
- March 2017: version 1.1, the first major feature update to Kotlin, with initial JavaScript support.
- May 2017: first-class Android support for Kotlin announced at Google I/O.
- November 2017: version 1.2, with the first version of multiplatform projects.
- October 2018: version 1.3, containing stable coroutines.
- May 2019: Android development going Kotlin-first announced at Google I/O.

Let's take a moment to review some of the previously mentioned language attributes, with this history now in mind:

- **Interoperability**: JetBrains had hundreds of thousands of lines of Java code that they could never just throw away. The new code written in Kotlin and the old code written in Java had to be able to communicate efficiently and effortlessly.
- **Pragmatism**: The language was born to serve a specific need, a real industrial project.
- **Tooling**: Language and tooling could be developed side-by-side, in-house, and complement each other perfectly.


# Tooling and environment

TODO: COMPILATION TO BYTECODE (interop with Java!)

TODO: IntelliJ, Gradle, scratch file, REPL, decompiler


# Basic syntax

### Variables

Let's take the first thing you'd want to do in a language, and declare a variable!

>Note: In the beginning, we'll look at the Java equivalents of the Kotlin code in case you need them for reference. Remember, Kotlin *does not* actually compile to Java!

```kotlin
var x: Int = 0              // int x = 0;
```

Let's take note of a couple things:
- You declare variables with the `var` keyword.
- The variable name *precedes* the type.
- Semicolons are optional (but really, you shouldn't use them).

You should only use `var` when you explicitly want a *mutable* **var**iable. By default, use `val`, which declares an *immutable* **val**ue.

```kotlin
val y: Int = 1              // final int y = 1;
```

That's better. We can make another improvement to this declaration, by making use of *type inference*.

```kotlin
val z = 2                   // final int z = 2;
```

Kotlin is statically typed and has a very strong, strict type system. This variable is still typed to be an `Int` just like before, but you can omit the type in your code, as the compiler can *infer* it itself. You'll see a lot of this happening in Kotlin code.

This mechanism means you'll never type out something as verbose as this again:

```java
final FileInputStream fis = new FileInputStream("filename");
```

Instead, you'll have the Kotlin compiler figure out the type for you in almost all cases:

```kotlin
val fis = FileInputStream("filename")
```

>Note: You may also notice here that there's no `new` keyword in Kotlin for constructor calls.

The simple number literal we had before was inferred to be an `Int`, but you can also use special formats for the other basic types:

```kotlin
val myLong = 1L             // final long myLong = 1;
val myFloat = 1f            // final float myFloat = 1;
val myDouble = 1.0          // final double myDouble = 1;
```

##### Primitives vs boxed types

TODO write this

##### Strings

The last basic type that's worth mentioning here is `String`, which behaves much like a `String` in Java. It's declared with quotation marks:

```kotlin
val name = "Sarah"           // final String name = "Sarah";
```

Kotlin also supports *string templates*, which is an easy way to place values inside a `String`, without having to use lots of concatenation:

```kotlin
val sum = "$x + $y + $z = ${x + y + z}"     // outputs "0 + 1 + 2 = 3"
```

Single values can be inserted with just a `$` prefix, and expressions can be computed using additional curly braces `${...}`.

### Functions

##### Our first function

Let's move on to functions. We'll convert this very simple function to Kotlin first, which just adds two numbers together, and returns the result.

```java
int add(int x, int y) {
    return x + y;
}
```

Here's a Kotlin equivalent of this code:

```kotlin
fun add(x: Int, y: Int): Int {
    return x + y
}
```

Some important observations about the syntax:

- We use the `fun` keyword to declare a function. (Yay!)
- The names precede the types in the parameter list, just like we've seen with variables.
- The return type comes after the rest of the function header as well, following the `name: Type` structure yet again.

For functions as simple as this one, that only compute a single expression and return its value, Kotlin offers a shorthand syntax called an *expression body*:

```kotlin
fun add(x: Int, y: Int): Int = x + y
```

And type inference can also kick in here, since the type of the `x + y` expression, an addition of two `Int` values is known by the compiler to be an  `Int`:

```kotlin
fun add(x: Int, y: Int) = x + y
```

#####   Functions that don't return anything

There's another case where the return type can be omitted, this is when the function doesn't return anything. This is equivalent to a function returning `void` in Java.

```kotlin
fun noReturnValue() {
    /* Empty */
}
```

Technically, functions like this still do return *something* in Kotlin. The language doesn't have this special case that Java has with `void` functions. Functions where you don't return a meaningful value - like the one above - will implicitly have a return type of `Unit`. You can also write this out explicitly, although the IDE will warn you that it's unnecessary.

```kotlin
fun noReturnValue(): Unit {
    /* Empty */
}
```

Unit is an empty class that has a single instance. This makes it perfect for representing "no meaningful value". Returning this from methods like the one above gives us some interesting possibilities, for example you can assign the return value of this function to a variable, which will then store the meaningless `Unit` value:

```kotlin
val result: Unit = noReturnValue()
println(result) // kotlin.Unit
```

We'll see that this type also plays well with generics. We won't need the weird distinction that Java makes between `void` and `Void`, we'll just use `Unit` for everything. But we're getting ahead of ourselves. Spoilers.

##### Default and named parameter values

Functions come with some neat new features in Kotlin. One of these is *default parameter values*. Let's write a function that mimics the registration of a user.

```kotlin
fun register( 
    username: String, 
    password: String = "12345678", 
    email: String = ""
) {
  // Pretend that there's something useful here.
  println("$username $password $email")
}
```

This function takes three arguments, and it defines default values for the last two. Note the formatting of each parameter on a separate line, this is conventional in Kotlin for functions with long signatures.

Having these default parameters in place means that we can call this method with three, two, or just one parameter. For any parameters that are not provided, the default value will be used instead.

```kotlin
register("piglet", "0h_d34r", "piglet@hundred-acre-wood.co.uk")
register("owl", "tea_party")
register("eeyore")
```

Another feature that works nicely in conjunction with default values is *named parameters*. For any function defined in Kotlin, you can optionally specify the names of the parameters when you call the function. Our previous calls could be made like this (note again the formatting of the lengthy call, on multiple lines.):

```kotlin
register(
    username = "piglet",
    password = "0h_d34r",
    email = "piglet@hundred-acre-wood.co.uk"
)
register(username = "owl", password = "tea_party")
register(username = "eeyore")
```

Naming our parameters, especially in cases like this where we are passing in a bunch of simple strings to a function, can help us avoid mixing up the parameter order, making our code safer. It also improves readability, as which argument fulfills which parameter is immediately clear at the call site.

Combined with default values, we can use this to omit parameters that have default values, but are not at the end of the parameter list:

```kotlin
register("tigger", email = "tigger@hundred-acre-wood-co.uk")
```

### Control structures

Let's continue with the basics and get to know our control structures. Most of these will be familiar already, so you'll have no problem getting started with them, but they almost all get some usability upgrades in comparison to Java.

##### Conditionals

The classic `if` statement is available in Kotlin just like you'd expect:

```kotlin
if (age < drinkingAge) {
    println("We can't serve you")
} else {
    println("Have a beer")
}
```

They come with the exciting twist of being not only statements, but also *expressions*, i.e. they have a return value. This return value is whatever the last expression in the branch that was executed is.

```kotlin
val discount = if (age < adultAge) {
    println("Calculating discount")
    val diff = adultAge - age
    100 - diff * 5
} else {
    println("No discount available")
    0
}
```

If you omit the braces, you get a very concise syntax for these expressions:

```kotlin
val max = if (a > b) a else b
```

For this reason, the so-called ternary operator (`a > b ? a : b`) is not present in the language [at this point](https://youtrack.jetbrains.com/issue/KT-5823).

##### Switches get ~~stiches~~ improvements

##### Exceptions

Exceptions in Kotlin are handled using a `try-catch` block (with an optional `finally` clause):

```kotlin
db.open()
db.beginTransaction()
try {
    db.insert(11)
    db.commitTransaction()
} catch (e: IllegalStateException) {
    db.rollbackTransaction()
} finally {
    db.close()
}
```

As you might expect at this point, `try-catch` is also an expression, and it returns the last expression in the `try` branch if nothing is thrown from that branch, and the last expression of the `catch` branch otherwise:

```kotlin
val input: String = readUserInput()
val value: Double = try {
    input.toDouble()
} catch(e: NumberFormatException) {
    0.0
}
```

>Note that instead of using `Double.parseDouble` and similar methods, Kotlin offers methods on the `String`type that let you easily convert them to other types, such as [`toDouble`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-double.html) or [`toInt`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-int.html).

One last notable design choice is that there are *no checked exceptions* in Kotlin. This means that there's no requirement of declaring what exceptions a given function may throw, and you're not forced to handle non-`RuntimeExeptions` by the compiler either.

This choice was made based on the experience that Java's checked exceptions did a lot more to inconvenience developers than to improve the safety of code, and often just resulted in many empty `try-catch` wrappers around functions that declared exceptions being thrown from them.

##### Loops

Last but not least, let's talk about loops. `while` and `do-while` loops have nothing special about them. They check at the beginning and end of the loop respectively, and run until their condition evaluates to `true`.

```kotlin
val entries = ...
while (entries.hasNext()) {
    println("Entry: ${entries.next()}")
}
```

`for` loops, on the other hand, are more interesting. The C-style `for` loop with three parts in its header is not present in the language. Instead, anything that can provide an `Iterator` can be iterated with `for` loops.

For example, here's how you can iterate over a list of numbers, created with the [`listOf`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/list-of.html) factory function:

```kotlin
val myNumbers = listOf(1, 2, 5, 14, 42, 132, 429)
for (number in myNumbers) {
    println(number)
}
```