# Chapter 4: Functional programming and collections

In lecture 2, we've looked at Kotlin's support for object oriented programming. The other major paradigm that Kotlin supports is functional programming.

Some general aims of functional programming are:

- Functions as a first-class citizens
  - In most OO focused languages, [functions are inferior to classes](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html). They can not exist outside of a class, they are just parts of classes, the larger, more important concept.
  - In functional programming, functions can exist on their own (remember [C](https://en.wikipedia.org/wiki/C_(programming_language)), which didn't even have classes?).
- Pure functions
  - A function is considered pure if it doesn't depend on anything but its parameters, and produces no side effects. Methods in OO are rarely pure. Most of them make use of state inside classes, and modify state.
  - Pure functions have many advantages, the most important perhaps being *referential transparency*, which means that they always yield the same results for the same inputs. This makes it very easy to reason and test these functions.
- Immutability
  - Mutable state is the enemy of functional programming, for good reason. The more mutable state, the more complex the code. Therefore, functional programming prefers immutable data structures and variables over mutable ones.
  - We've already seen how Kotlin promotes these ideas with its preference of `val` over `var`, and the `copy`method of data classes. We'll find more of the same when we get to collection types.
- Declarative over imperative style
  - Instead of giving step-by-step instructions on *how* to manipulate data, functional programming focuses on *what* to do with the data.
  - This sounds rather abstract at first, but again, this is something that will be prevalent in Kotlin's collection handling.

So when can a language declare that it's functional? Does it have to meet all of the requirements above? Or even more than these? It's very hard to say definitely. [Haskell](https://www.haskell.org/) is sometimes touted as the only true, purely functional language. However, many languages support some amount of the concepts of functional programming, which blurs the lines quite a bit.

As far as JetBrains is concerned, their stance is that they consider the support for top level functions the determining factor. This makes Kotlin a functional language, in addition to being object oriented.

## Code organization

We've seen that Kotlin has top level functions. They're what make the "hello world" program in Kotlin is as simple as this:

```kotlin
fun main() {
    println("Hello world")
}
```

Compare this to Java's "hello world":

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello world");
    }
}
```

Just think of how many concepts you'd have to explain to someone getting started with Java to print their first message in the language. What's `public`? What's a `class`? What's `static`? What's `void`? What's a `String[]`? And so on.

So Kotlin does allow for top level functions, and you can place multiple of these in a file. In fact, you can place almost anything in a single file. Multiple functions, interfaces, public classes, and properties can all exist in one file.

These files are sorted into packages, which is declared at the top of the file. Just like classes, other top level declarations can be used in other packages by importing them.

>Unlike with Java, the packages that files reside in don't have to match the directories they're in under the source folder. There is an [official recommendation](https://kotlinlang.org/docs/reference/coding-conventions.html#directory-structure) that pure Kotlin projects should leave out the directories for the "root package" of the application, and place anything in that package directly in the root of the sources folder. However, in practice, the Java conventions are followed 99.99% of the time.

The Java language isn't what requires everything to be wrapped in classes - this is a requirement on the bytecode level. So how are all the top-level declarations in Kotlin files compiled to bytecode? There's only one possible answer: they're wrapped in classes.

For example, take this piece of Kotlin code, residing in a file called `TextUtils.kt`:

```kotlin
package util

val LOWERCASE_ALPHABET = "abcdefghijlkmnopqrstuvwxyz"

fun isEmpty(str: String?): Boolean {
    return str != null && str.length > 0
}
```

We end up with a class called `TextUtilsKt` at the bytecode level, with all static contents:

```java
public final class TextUtilsKt {
    @NotNull
    private static final String ALPHABET = "abcdefghijlkmnopqrstuvwxyz";

    @NotNull
    public static final String getALPHABET() {
        return ALPHABET;
    }

    public static final boolean isEmpty(@Nullable String str) {
        return str != null && str.length() > 0;
    }
}
```

This is good news for any Java clients, as they can access this functionality by calling static methods on a class. However, the call site is littered with the `Kt` postfix:

```java
public static void main(String[] args) {
     if (TextUtilsKt.isEmpty(args[0])) {
         // ...
     }
 }
```

Thankfully, the name of this generated class can be controlled by placing the [`@JvmName`] annotation on the entire file:

```kotlin
@file:JvmName("TextUtils")

package util

/* ... declarations ... */
```

This will have the expected effect of renaming the class to just `TextUtils`, which is much nicer to call from Java.

## Extensions

One of the often advertised, high-profile features of Kotlin are extension functions. These allow you to add new functionality to existing classes, without touching the class definition itself. This means that you can add extensions even to classes (or types, really) that you don't own.

For example, if you need a quick way to get the last character of a `String`, you can add an extension function like this:

```kotlin
fun String.lastChar(): Char {
    return this[this.length - 1]
}

fun main() {
    println("Steve".lastChar())
}
```

Let's take a close look at this piece of code:

- The type that you're extending is marked before the name of the function, in this case, with the `String.` syntax. You're defining a function _on_ the `String` type.
- Inside the function, you can write code as if you were writing a real method inside the `String` class. The instance that your extension was called on is available as `this`. This instance is called the *receiver* inside the extension function.
- Invoking an extension has the same syntax as any real method of the class. If it's in a different package, it does have to be imported, much like a top level function would be.

So... How is this possible? Don't worry, Kotlin doesn't attempt to rewrite the bytecode of existing classes. Instead, extensions are implemented as simple static functions on the bytecode level. If we decompile the bytecode from the code above, we'll see just that:

```kotlin
public static final char lastChar(@NotNull String $this$lastChar) {
    Intrinsics.checkParameterIsNotNull($this$lastChar, "$this$lastChar");
    return $this$lastChar.charAt($this$lastChar.length() - 1);
}

public static final void main() {
    char var0 = lastChar("Steve");
    System.out.println(var0);
}
```

The receiver of the function simply becomes the first parameter of the function, and any other parameters are shifted over by one. This implementation detail is very important, as it poses some limitations on extensions, and it explains some of their behaviour.

Since extensions aren't real members, just static functions operating on an object, they *can't access non-public API of the type that they're being added to*. This would break encapsulation.

As extension functions are static, they are resolved statically, which is a significant difference from how regular members work. Consider the following example:

```kotlin
abstract class Animal {
    open fun identify() {
        println("This is an animal.")
    }
}

class Cat() : Animal() {
    override fun identify() {
        println("This is a cat!")
    }
}

fun main() {
    val animal: Animal = Cat()
    animal.identify() // This is a cat!
}
```

Even though we are holding onto a reference of a `Cat` as an `Animal`, when we call its `identify` method, the method belonging to the `Cat` class is involved. This feature - dynamic dispatch - is the basis of polymorphism, a core concept of object oriented programming. It allows for the concrete implementation to be invoked to be chosen at runtime.

So what happens if we move both of these `identify` methods into extensions instead?

```kotlin
abstract class Animal

fun Animal.identify() {
    println("This is an animal.")
}

class Cat() : Animal()

fun Cat.identify() {
    println("This is a cat!")
}

fun main() {
    val animal: Animal = Cat()
    animal.identify() // This is an animal.
}
```

We suddenly lose dynamic dispatch. Since the `identify` functions are static, the correct one to call has to be resolved at compile time. At that time, all we know for certain is that we have an `Animal` instance. Technically, anything can end up in that reference by the time we have to call `identify` at runtime.

---

Extensions are a powerful tool that let you add missing functionality to types, and make existing, awkward APIs easier to use when you write Kotlin code. The Android ecosystem, for example, has [first-party](https://developer.android.com/kotlin/ktx) libraries containing nothing but extensions around existing API.

For example, showing a quick message called a [Toast](https://developer.android.com/guide/topics/ui/notifiers/toasts) on-screen requires you to use this API, which requires you to pass in a `Context` object as the first parameter, a length as the last one, and then _not forget to call `show`_ after creating the `Toast`.

```kotlin
Toast.makeText(this, "Network timed out", Toast.LENGTH_SHORT).show()
```

This can be very easily be wrapped up in an extension which is effortless to call when you're inside a class that's a `Context`itself:

```kotlin
fun Context.toast(message: String, duration: Int = Toast.LENGTH_SHORT) {
    Toast.makeText(this, message, duration).show()
}

toast("Network timed out")
```

Note the use of the default parameter value, which allows you to provide less parameters in the common case, but still gives you the ability to customize the value, should you need to.

### Extension oriented design

A significant amount of the functions in the standard library are defined as extensions on commonly used types. Many of them extend common classes, such as `String` or `File`. We'll take a closer look at these extensions later.

However, many functions that operate on standard library types (which could be easily just added inside the class body) are also defined in extensions. This allows the classes to contain just the core, essential functionality that they need. Everything else can be defined as extensions, which are loosely coupled to the class, can change easily later.

For example, take this `Node` class that can be used to build a binary tree:

```kotlin
class Node(val value: Int) {
    var leftChild: Node? = null
    var rightChild: Node? = null

    fun traverse() {
        leftChild?.traverse()
        println(value)
        rightChild?.traverse()
    }
}
```

Its `traverse` member doesn't _really_ belong in this class. Traversing is not something a `Node` can do, it's a way that we use a `Node`. The class itself is just a data holder, it doesn't have behaviour.

>This member function also prevents anyone from adding their own function named `traverse` as an extension. Members always take precedence over extensions.

Instead of this function living inside `Node`, we can provide it as an extension:

```kotlin
class Node(val value: Int) {
    var leftChild: Node? = null
    var rightChild: Node? = null
}

fun Node.traverse() {
    leftChild?.traverse()
    println(value)
    rightChild?.traverse()
}
```

This allows other developers to define their own `traverse` extensions in different packages, which may perform a different kind of traversal (e.g. pre-order).

>What happens if you need to use multiple extensions with the same name in the same file? You have to [get a bit creative with your imports](https://stackoverflow.com/a/42753052/4465208). You can use the `import com.myutils.traverse as traverseInOrder` syntax to rename any imported symbol for a given file. This lets you resolve extension clashes, and conveniently use multiple classes with the same name without having to fully qualify one of them everywhere in the file.

This pattern is referred to as [*extension oriented design*](https://medium.com/@elizarov/extension-oriented-design-13f4f27deaee). It's prevalent in many first-party Kotlin libraries, for example in the standard library's collection processing functions, sequences, and coroutines.

### Extension properties

Extension properties are much the same as extension functions under the hood, but they come with the regular property syntax. *They may only be computed properties, because to store data, the original class would have to be modified.*

As an example of an extension property, let's add a `bd` property to the `Int` type, to quickly and easily create `BigDecimal` instances:

```kotlin
val Int.bd: BigDecimal
    get() = BigDecimal(this)
    
val thousand: BigDecimal = 1000.bd
println(thousand)
```

Inside the getters and setters of these properties, the current instance is of course available as `this`.

### Member extensions

A special kind of extensions is those that are declared *inside a class* (or interface). In these cases, the extensions become quite different from other, top-level extensions.

They will have two receivers available as `this`. The *dispatch receiver*, which is the instance of the enclosing class, and the *extension receiver*, the instance of whatever type the extension was defined on. In ambiguous cases, the extension receiver will take precedence:

```kotlin
class Queue(val length: Int) {
    fun String.process() {
        println(length) // String's length
        println(this.length) // String's length
        println(this@Queue.length) // Queue's length
    }
}
```

The dispatch receiver can be accessed with a [qualified `this`](https://kotlinlang.org/docs/reference/this-expressions.html#qualified), which is also used when choosing from multiple implicit receivers in other situations, such as in nested classes.

These extensions are also not static, they are regular member functions. This means that overriding and dynamic dispatch *does* happen, although not by the type that is extended, but by the containing type.

You can make these extensions  `open` or `abstract`, and force subtypes to implement them:

```kotlin
abstract class Validator {
    abstract fun String.isValid(): Boolean

    fun validate(str: String?): Boolean {
        return str != null && str.isValid()
    }
}

class EmailValidator : Validator() {
    override fun String.isValid(): Boolean {
        return this.contains('@')
    }
}
```

There _are_ valid use cases for these types of extensions. These declarations are only visible within the class that they're declared in, which is a way of scoping extensions that won't be widely used in a project.

However, they also come with some surprising behaviour, which can be avoided by using private, top-level extensions, or even function-local extensions instead, if applicable.

## Function types

Other than supporting top-level, standalone functions, perhaps the most important functional aspect of Kotlin is its support for function types.

Take this class and this function for example:

```kotlin
data class Person(val name: String, val age: Int)

fun getAge(person: Person): Int {
    return person.age
}
```

This function takes a `Person` parameter, and returns an `Int`. The type of this function is `(Person) -> Int`. The type function that takes no parameters and returns no value would be `() -> Unit`. A function that adds two whole numbers together could have the type `(Int, Int) -> Int`.

Variables can have these function types in Kotlin. If we wanted to store the function above in a variable, we could either store a reference to it:

```kotlin
val ageGetter: (Person) -> Int = ::getAge
```

Or declare the entire function in-line, and assign it to a variable immediately:

```kotlin
val ageGetter: (Person) -> Int = fun(person: Person): Int {
    return person.age
}
```

Functions can be invoked from references the same way as usual, with the `()` syntax, passing in any parameters:

```kotlin
val julie = Person("Julie", 36)
println(ageGetter(julie)) // 36
```

### Lambdas

Instead of declaring anonymous functions with the full function syntax and the `fun` keyword, we can use function literals, or *lambdas*. The previously seen `ageGetter` function could be implemented in a lambda like this:

```kotlin
val ageGetter = { person: Person -> person.age }
```

Lambdas may contain multiple expressions, and they return their last expression, without a `return` keyword:

```kotlin
val ageGetter = { person: Person ->
    println("Getting the age of ${person.name}")
    person.age 
}
```

The type of `ageGetter` is still `(Person) -> Int`, but we let the compiler infer it for brevity. This function can still be invoked the same way as before:

```kotlin
val julie = Person("Julie", 36)
println(ageGetter(julie)) // 36
```

If we do provide the type on the left hand side, we can omit some type information in our lambda:

```kotlin
val ageGetter: (Person) -> Int = { person -> person.age }
```

For lambdas *that have a single parameter*, one final simplification may be performed - we can skip naming the parameter altogether. In this case, it will receive the implicit name `it`:

```kotlin
val ageGetter: (Person) -> Int = { it.age }
```

### Bound references

You can reference methods of a specific class, and then invoke them by passing in a concrete instance:

```kotlin
class Person(val name: String) {
    fun speak() {
        println("Hi, I'm $name!")
    }
}

val speak: (Person) -> Unit = Person::speak
val grace = Person("Grace")
speak(grace)
```

References may also be bound to a specific instance, for example:

```kotlin
val grace = Person("Grace")
val speak: () -> Unit = grace::speak
speak() // "Hi, I'm Grace!"
```

Dealing with these method references skirts the boundaries of Kotlin's reflection features, which we'll explore later on.

>To explore a bit, take a look at what the inferred types of these references would be if we didn't type them explicitly.

## Higher order functions

### Introduction

A function that takes another function as a parameter or returns a function is called a *higher order function*.

Kotlin has support for function types, and we've seen how we can store functions in variables. Passing them in and out of functions is a small step up from here technically, but it will open up a whole new world of possibilities.

Let's start with one of the simplest of higher order functions, one that executes a given piece of code passed to it:

```kotlin
fun execute(actions: () -> Unit) {
    actions()
}

execute({ println("Hello world") }) // Hello world
```

Calling the function passed in just once is the simplest thing to do. We could also store this function, `actions` - which really is just a piece of code at the call site - and we could invoke it any later point in time.

Or we could introduce a new parameter, and call it repeatedly - we'll also rename our function, which does more than just execute the parameter now.

```kotlin
fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

repeat(3, { println("Hello world") })
```

At this point, the IDE is screaming at us with a warning, suggesting that we change our code style. Whenever a function's last parameter is a function type, and that parameter is being fulfilled by a lambda, that lambda can be moved outside the parentheses of the parameter list:

```kotlin
repeat(3) { println("Hello world") }
```

If we reformat this a bit with some newlines, our `repeat` function will start looking *a lot* like a built-in language construct...

```kotlin
repeat(3) {
    println("Hello world") 
}
```

### FunctionX types

We've seen that with function types, we can assign functions to variables, and even pass them around - a lot of possibilities open up in front of us. How does this work under the hood?

Kotlin functions on the JVM are implemented as anonymous inner classes, which implement certain interfaces. The `Function0` interface is used for functions that take no parameters. For single-parameter functions, there's a `Function1` type. And so on, and so on.

>These `FunctionX` types only go up to `Function23`, but the upper limit for the number of function parameters is 255 on the JVM. Try to find out what happens with functions that have more than 23 parameters!

These functional interfaces - such as `Function1` - all require just a single `invoke` method, which will have a signature that corresponds to their function type, and its body will contain the body of the function in whatever class implements it.

Creating instances of classes like these, storing references to them, and calling methods on them are very basic things that you could do in Java as well - Kotlin just provides all the syntactic sugar for doing it conveniently.

In fact, let's call our `repeat` function from Java, to see how we can create the `Function0` it requires as a parameter by hand:

```java
repeat(3, new Function0<Unit>() {
    public Unit invoke() {
        System.out.println("Hello world");
        return Unit.INSTANCE;
    }
});
```

`Unit`, the generic parameter of `Function0`, is the return type of this no-parameter function type.

>Note that `Unit`-returning functions, and especially lambdas, are inconvenient in Java, as you have to explicitly return it, unlike with `void` methods.

### Optimizations

Let's go back to our previous call from Kotlin that we've made to this same `repeat` function:

```kotlin
repeat(3) { println("Hello world") }
```

... and see what it decompiles to. We expect to see basically the same code as we've just written in Java...

```java
repeat(3, (Function0)null.INSTANCE);
```

Except the built-in decompiler isn't able to handle this code. This is a good example of things that it simply can't deal with right now. If we use a better decompiler, we'll quickly discover what's going on:

```java
final class HelloKt$example$1 implements Function0 {
    public static final HelloKt$example$1 INSTANCE =
    new HelloKt$example$1();
    
    public final void invoke() {
        String str = "Hello world";
        System.out.println(str);
    }
}
```

There was a class generated which implements `Function0` and prints `"Hello world"` in its `invoke` method, as expected. It also contains an extra member, however: a static instance of itself!

Since this lambda relies on no external values or parameters in its `invoke` method, the compiler optimizes it into a singleton, so that only a single instance of it is ever present and used in the program.

`null.INSTANCE` in the decompiler output, then, is just a read to this static field to get the instance, except the decompiler didn't manage to resolve the classname for some reason. What we should see here is this:

```java
repeat(20, (Function0) HelloKt$example$1.INSTANCE);
```

### Capturing values

We've seen what happens when a lambda relies on no external values. This often isn't the case though. Lambdas act as [closures](https://en.wikipedia.org/wiki/Closure_(computer_programming)), meaning that they will capture any variables from outer scopes that are referenced inside them.

Take for example this extension, which "multiplies" a string, making use of our existing `repeat` method:

```kotlin
fun String.multiply(times: Int): String {
    var result = ""
    repeat(times) {
        result += this
    }
    return result
}
```

The lambda being passed in to `repeat` here reads *and modifies* the `result` variable from an outer scope.

We can imagine capturing a variable with an anonymous class or lambda in Java as well - the requirement for this is that the reference being captured needs to be *final*:

```java
public static String multiply(final String $this, int times) {
    final String result = "";
    repeat(3, new Function0<Unit>() {
        public void invoke() {
            result = result + $this; // e: Cannot assign a value to final variable 'result' 
            return Unit.INSTANCE;
        }
    });
    return result;
}
```

However, modifying this `String` is another story. Since we can't change what the `result` reference points to, we'd need to modify the object it points to, but the `String` type on the JVM is immutable.

So that's our catch-22 here: we need the reference to be final so that we can capture it, but we also need it to be mutable so that we can assign newly created `String` instances to it. In Java, this seems unsolvable. In Kotlin, it compiles and works as expected.

What's happening under the hood? Let's decompile!

```java
@NotNull
public static String multiply(@NotNull final String $this$multiply, int times) {
    Intrinsics.checkParameterIsNotNull($this$multiply, "$this$multiply");
    final ObjectRef<String> result = new ObjectRef(); // 1
    result.element = ""; // 2
    repeat(times, new Function0() {
        public final void invoke() {
            ObjectRef var10000 = result; // 3
            String var10001 = var10000.element;
            var10000.element = var10001 + $this$multiply;
        }
    });
    return result.element; // 4
}
```

1. There's an instance of the `ObjectRef` class being created. This class is just a wrapper around a generic value (its definition here is slightly simplified):

    ```java
    public class ObjectRef<T> {
        public T element;
    }
    ```
    
    This `ObjectRef` reference is *final*, so it can be captured by an inner class.

2. The empty `String` instance we start with is stored in the *mutable* reference inside the `ObjectRef`.
3. Inside the lambda, the current `String` instance is removed from the `ObjectRef`, concatenation happens, and then the new instance is placed in the `ObjectRef`.
4. Whatever reference ends up being in the `ObjectRef` by the time the method reaches its last line is returned.

`ObjectRef` is one of several of these kinds of reference wrappers that can provide an extra level of indirection in the bytecode to allow capturing mutable references. This one is used for reference types, such as `String`. An additional wrapper just like it exists for each primitive type - [see them all here](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/Ref.java).

### Inline functions

Passing around lambdas is simple, convenient, and it allows for powerful abstractions that we'll see great examples of when we discuss collections. However, the previous example shows that we pay a price when passing in lambdas to functions. Each lambda will cost an object allocation, and capturing references can also lead to further allocations.

Let's be greedy. What if we could have our cake and eat it too? What if we could get these abstractions for "free", with no runtime performance hit?

This is where *inline functions* come to the rescue. Their name describes what they are fairly well. They are functions that get *inlined* to wherever they're called from. For the simplest example, take the `greet` method, and the call to it in `main`:

```kotlin
inline fun greet(name: String) {
    println("Hello, $name!")
}

fun main() {
    greet("Abby") // Hello, Abby!
}
```

Decompiling the `main` function, you'd usually expect to see just one line, the call to `greet`. Instead, you see this:

```java
public static final void main() {
    String name$iv = "Abby";
    String var2 = "Hello, " + name$iv + '!';
    System.out.println(var2);
}
```

The entire body of the `greet` function has been "copy-pasted" to the call site, with any parameters substituted as well. This is what inlining does.

With a function as simple as this, the IDE will warn us that the gains from inlining the method won't be very significant. It's up to you to decide in each case whether inlining a certain function is worth it.

>If you have a very long, complex function, inlining might not be the best idea. Every time you call it, its contents will be injected to the call site, bloating your compilation output.

Where inlining is certainly useful is with higher order functions, as it can get rid of our lambda allocations. Just like parameters are substituted into the inlined function body, so are the contents of lambdas that are called inside the function being inlined.

Taking our previous example of `multiply`, and adding the `inline` modifier to `repeat`:

```kotlin
inline fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

fun String.multiply(times: Int): String {
    var result = ""
    repeat(times) {
        result += this
    }
    return result
}
```

After decompiling, there's no call to `repeat` anymore. The loop from that function body simply exists directly in the `multiply` method, as if we've written it ourselves right there:

```java
@NotNull
public static String multiply(@NotNull String $this$multiply, int times) {
    Intrinsics.checkParameterIsNotNull($this$multiply, "$this$multiply");
    String result = "";
    int var4 = 0;
    for (int var5 = times; var4 < var5; ++var4) {
        result = result + $this$multiply;
    }
    return result;
}
```

Inlining is most often used with higher order functions, where there is a very clear performance gain. Another good use case is when wrapping existing, difficult to use API with extensions. By inlining your wrappers, the bytecode produced is _exactly_ the same as if you've written the code the complex way (no extra call to a static helper function), but your source can be simpler thanks to your extensions. Free abstraction!

##### Non-local returns

Return statements inside lambdas can get quite complicated. Take the example where we want to `return` inside the `repeat` function on some condition:

```kotlin
fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

fun test() {
    repeat(10) {
        if (Random.nextDouble() > 0.6) {
            println("Failure")
            return
        }
        println("Success")
    }
}
```

You might expect this `return` to return within the lambda, and to skip just a single iteration of the loop. This is not the case. The rule for a `return` statement is that by default, it always returns from the closest `fun`. In this case, this would be the `test` function. Such a return inside this lambda isn't allowed, as the `repeat` function could do many things with its parameter - for example, store it and invoke it later. In those invocations, the `return` from `test` wouldn't make any sense!

>The closest `fun` rule means that there's a difference between anonymous functions declared with `fun() {}` and function literals declared with `{}` when it comes to returns!

So how do we return from just a single iteration of the lambda? We have to qualify the `return` statement with the scope that we want to return in:

```kotlin
fun test() {
    repeat(10) {
        if (Random.nextDouble() > 0.6) {
            println("Failure")
            return@repeat
        }
        println("Success")
    }
}
```

What about the other case, can we somehow return from the `test` function from inside a lambda? The solution is to inline the `repeat` function again. This way, we know that the lambda we pass to it will only be executed in place, in the context of the `test` function. This will let us compile our original code above, and cancel `repeat` altogether on the first failure.

##### noinline and crossinline

Some special cases around inlining have to be quickly mentioned here.

When you inline a function, by default, all of its lambda parameters will be inlined. You can use `noinline` to mark any lambda parameters that you _don't_ want to be inlined - instead, they'll be passed in the regular way, with a function object being allocated for them. This will prevent you from using non-local returns in these lambdas, but allow you to, for example, store them in properties.

>TL;DR: `noinline` prevents the inlining of a given parameter with a function type, and passes it in the regular way, like to any non-inline function.

A slightly more complex use case is when you're passing in a lambda somewhere and you want it inlined, but you can't allow non-local returns from it, as it doesn't make sense in the execution context. For example, here, `body` would be inlined inside the `run` function's body. At the call site, since we're in an inline function, we'd expect to be able to use `return` freely to return from `test`, but the `Runnable` that's being created has no context of the `test` method, and couldn't perform a return from it.

```kotlin
inline fun funky(body: () -> Unit) {
    val f = object: Runnable {
        override fun run() { 
            body()
        }
    }
    f.run()
}

fun test() {
    funky {
        println("This is really quite complicated!")
    }
}
```

We could solve this by marking `body` with `noinline`, but then we'd suffer an object allocation, and inside `run`, we'd see something like this after compilation:

```java
new Runnable() {
    public void run() {
        body$iv.invoke();
    }
};
```

We can use `crossinline` instead, which will still inline the lambda, but prevent non-local returns from being used inside it. This fixes our context issues, and still saves us the allocation:

```java
public static void test() {
    Runnable f = new Runnable() {
        public void run() {
            String var2 = "This is really quite complicated!";
            System.out.println(var2);
        }
    }
    f.run();
}
```

>TL;DR: `crossinline` disables non-local returns in a parameter with a function type, removing some limitations on how you may use it.

### Typealiases

Typealiases let you rename types. As their name says, they don't create new types, just aliases for existing ones. This can come in handy when you want to rename a type for local use (similarly to renaming an imported symbol, but not just for a single file), and they are perhaps most often used to give semantics to function types.

Take the example of a `View` interface that allows you to register a click listener:

```kotlin
interface View {
    fun setOnClickListener(listener: () -> Unit)
}
```

Instead of the regular function type of `() -> Unit`, you may choose to be more expressive, and use a typealias for this parameter:

```kotlin
typealias OnClickListener = () -> Unit

interface View {
    fun setOnClickListener(listener: OnClickListener)
}
```

These two types will be cross-compatible. You can assign an `OnClickListener` to something with the type `() -> Unit` and vice versa, because they *are* the same type.

>We'll eventually take a look at *inline classes*, which are quite similar, but do introduce distinct, new types.

### SAM conversion, SAM constructor

On the topic of function types, one of Kotlin's primary Java interop features has to be mentioned. We've seen the `FunctionX` interfaces in Kotlin, which served the sole purpose of wrapping a block of code in a class instance, with their single `invoke` method.

Modern Java versions support lambdas as well, but lacking truly standard function types, many libraries introduce their own (in addition to the many that are included in the platform, such as [`Predicate`](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html) or [`BiFunction`](https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html)). You are encouraged to create your own as well, and mark it with [`@FunctionalInterface`](https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html), indicating that it's supposed to be used in a functional manner.

The requirement for a functional interface is simple: have a single method that you require to be implemented. These are often also called Single Abstract Method (SAM) interfaces.

Kotlin supports passing in lambdas and functional types as parameters where an implementation of a Java-declared functional interface is expected. For example, given this Java code:

```java
interface View {
    interface OnClickListener {
        void onClick(View view);
    }

    void setOnClickListener(OnClickListener listener);
}
```

The way to pass in an instance of `OnClickListener` in Kotlin would be to create a separate class that implements the interface and instantiate it, or to use an `object` expression:

```kotlin
view.setOnClickListener(object: View.OnClickListener {
    override fun onClick(view: View) {
        println("Clicked!")
    }
})
```

This is a lot of code for just the single line print statement that we're trying to pass in here. Using *SAM conversion*, we can pass in a lambda that matches the signature of the single method in the interface, in this case, one that has the type `(View) -> Unit`:

```kotlin
view.setOnClickListener { 
    println("Clicked!") 
}
```

This feature, [for](https://youtrack.jetbrains.com/issue/KT-7770) [now](https://youtrack.jetbrains.com/issue/KT-11129), only works when the interface is declared in Java, as well as the method taking it as a parameter. SAM conversions for Kotlin-declared interfaces is not possible at all (the reasoning being that you could just use function types in Kotlin). When only the method is written in Kotlin, or when the conversion would be ambiguous due to overloads, the slightly lengthier *SAM constructor* syntax may be used:

```kotlin
view.setOnClickListener(View.OnClickListener {
    println("Clicked!")
})
```

>One drawback of SAM conversions is that inside the lambda being passed in, there is no `this` reference to the lambda instance. If you need this reference (for example, for a listener to unregister itself in certain cases), you'll have to use the full object expression syntax.

## Collections

### Collection types

While you can use all the collection types of the JDK directly when working in Kotlin, it is discouraged. Kotlin's original and primary target *is* the JVM, but there is a huge push by JetBrains to make it [multiplatform](https://kotlinlang.org/docs/reference/multiplatform.html), and support JS and Native as well.

For this reason, Kotlin introduces its own collection interfaces, which are independent of the platform you're running on. If you're using Kotlin on the JVM, the implementations of any collections you're using will still be the original JDK classes, e.g. `java.util.ArrayList` or `java.util.HashSet`. These are not reimplemented by the Kotlin standard library, which has some great benefits:

- These are well-tested implementations, which are maintained anyway.
- Using the exact same classes makes interop with Java a breeze, as you can pass them back and forth without having to perform conversions or mapping of any kind.

All Kotlin does is introduce its own collection semantics  _over_ these existing implementations, in the form of the standard library interfaces. A small bit of [compiler magic](https://kotlinlang.org/docs/reference/java-interop.html#mapped-types) makes it so that these interfaces are implemented by the existing JDK classes as well.

Take the example of lists - a dynamically resizable, ordered collection. In Java, there is a [`java.util.List`](https://docs.oracle.com/javase/8/docs/api/java/util/List.html) interface which defines what all lists should be capable of doing, and how they are to be used. Most of the time when we need a list, we create [`java.util.ArrayList`](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html) instances without thinking twice about it. Many times we also require `ArrayList<Whatever>` instances as function parameters, and returns `ArrayList<Something>` types, even though being backed by an array is just an implementation detail of a list that we rarely use.

Kotlin introduces two interfaces for each type of collection. A read-only interface, and a mutable (read-write) interface. For lists, there's [`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html) and [`MutableList`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html).

`List` defines just a few basic properties and methods: `size`, `isEmpty`, `contains`, `iterator`, `get`, and the like. Notably, none of the methods defined in this interface allow you to change the contents of the list. All of the mutating methods are defined in `MutableList`, which extends `List`. This has methods such as `add`, `remove`,  or `clear`.

Thanks to the aforementioned compiler magic (mapped types), existing Java collections implement these Kotlin interfaces. A `java.util.ArrayList` is a `MutableList`, and a `java.util.HashSet` is a `MutableSet`. This eases interoperability tremendously. Imagine having to convert collection types every time you cross the language boundaries.

![An overview of some of Kotlin's collection interfaces](./images/4_kotlin_collections_overview.png)

You should use these interfaces by default in your code instead of concrete implementation types, especially in public API:

- In the case of function parameters, this lets clients provide the function with whatever implementation of the collection they wish to give you. If your function can operate on anything that's a `List`, you should ask for just that interface - no reason to require an `ArrayList` or `LinkedList` specifically.
- If this is a return type, using these interfaces lets you change the specific implementation that you create internally in the future, without breaking client code. You can promise to just return a `MutableList` of things, and what implementation backs that list is not exposed to your clients.

If you write your code in a way such that it only relies on Kotlin standard library defined types, that code will be easily usable for non-JVM targets. If you reference `kotlin.MutableList` in your imports, that can immediately compile to JS code, because there's a Kotlin standard library implementation of that interface on each platform. Whether that maps to an existing class directly, wraps an existing class somehow, or is implemented for Kotlin from scratch, again, doesn't have to concern you. But if you refer to `java.util.TreeSet` in your code, that won't fly for the JS target, as the Java platform classes are not available there.

Can you still use classes such as `java.util.ArrayList` directly? Of course.

- If you don't see your code going multiplatform at some point, using Java collections directly is perfectly okay.
- If you need a specific implementation for a `List` or a `Set` for performance reasons, sometimes you'll have to use the Java classes directly.

Interestingly, in recent releases of Kotlin, these specific types of implementations (such as an array based list) are wrapped under standard library typealiases too, so that they're platform independent by default: see [`kotlin.collections.ArrayList`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-array-list/index.html) or [`kotlin.collections.HashSet`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-hash-set/index.html) for examples of this. These Kotlin-defined types will usually show up first in IntelliJ completion, so you'll find yourself being pushed towards using them wherever possible. The same thing goes for most exceptions, e.g. [`IllegalArgumentException`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-illegal-argument-exception/index.html).

![Typealiased concrete implementations in the standard library](./images/4_typealiased_concrete_implementations.png)

#### Creating collections

If you don't need a specific implementation of a certain type of collection, you can use the factory methods of the standard library to create them, such as `listOf`, `mapOf`, `mutableListOf`, `mutableMapOf`, and so on.

In the case of lists, this is super simple - you just provide the list of items that make up the list (in the case of a mutable one, the initial contents). All of these functions are generic, and they take a variable number of arguments:

```kotlin
val list1: List<Int> = listOf(1, 2, 3)
val list2: MutableList<Int> = mutableListOf(1, 2, 3)
val list3: List<Any> = listOf(1, "two", 3.0)
```

The types for these declarations are added for educational purposes - normally, they can just be inferred. Note how mixing types with no common supertype will yield a `List<Any>` in the last example.

A slightly more interesting endeavour is creating maps using factory functions. Here's a map of player names to scores being created:

```kotlin
val scores = mutableMapOf(
        "Jim" to 24,
        "Claire" to 20,
        "Amanda" to 30
)
```

This syntax seems quite magical, `to` looks like a special keyword to be used for creating a `Map` entry. However, nothing in this piece of code is magic. Here's the signature of the `mutableMapOf` function:

```kotlin
public fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V>
```

As you can see, it just takes a variable number (`vararg`) of `Pair` instances.

>[`Pair`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/index.html) and [`Triple`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-triple/index.html) are the only "tuple" types in Kotlin, and they're part of the standard library. The language doesn't support tuples, as data classes can easily serve the role of tuples, and they come with well-named values.

So all the syntax `"foo" to 5` does is create a `Pair<String, Int>`. It turns out that [`to`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/to.html) is nothing but a function:

```kotlin
public infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)
```

The `infix` modifier on a function that's either a member or an extension and takes a single parameter allows that function to be called with an operator-like syntax, dropping the `.()` symbols from its call site.

To sum up: using these factory functions for collections keeps your code more generic, and independent of the concrete underlying implementations. You don't know what specific class the standard library `mutableListOf` function will create for you - and you shouldn't care. All you need to know is that it will be an object that satisfies the contract of the `MutableList` interface.

#### A note on immutability

Like with `var` and `val`, you'll often see that official recommendations, the IDE itself, and the standard library APIs are pushing you towards the less mutable, read-only variants of these interfaces. You should always choose these by default until you actually do need mutability.

Kotlin's read only collection interfaces are not to be confused with truly immutable collections. Even though you might have a read-only view of a collection through a read-only interface, someone else might still have a reference to it as a more concrete, mutable type. Immutable collections for Kotlin are currently [a work in progress](https://github.com/Kotlin/kotlinx.collections.immutable/blob/master/proposal.md).

>This is especially true when interoperating with Java code. Whether you're giving a `List` or a `MutableList` to a Java client, they'll see it as a `java.util.List`, and see all the mutating methods on that interface. Slightly malicious Kotlin clients can also easily attempt to cast a `List` given to them as a `MutableList`.

##### Arrays

Arrays are fixed-size, ordered containers. Their contents are contiguous in memory, which yields _O(1)_ access to an element at any index, as well as very fast and efficient iteration for arrays or primitives. They are a rather special type in Java, which also affects their design and API in Kotlin. 

Arrays for reference types are represented by the `Array` class in Kotlin. For a Java `String[]`, we can create an `Array<String>` in Kotlin. How? With factory functions, of course.

```kotlin
val colours: Array<String> = arrayOf("green", "yellow", "purple")
```

What about non-reference types? We don't have the distinction between primitives and boxed types for basic types such as `Int` in Kotlin. What happens when we create an array of those?

```kotlin
val primes: Array<Int> = arrayOf(2, 3, 5, 7, 11, 13, 17, 19)
```

We end up with an `Array` all the same, which is the equivalent of an `Integer[]`. This means boxing, as well as no fast iteration due to the indirection of storing just the references to the values in the array, instead of the actual values themselves.

For each of the primitive types, Kotlin has special array types: `IntArray`, `DoubleArray`, and so on. These come with their own factory methods:

```kotlin
val primes: IntArray = intArrayOf(2, 3, 5, 7, 11, 13, 17, 19)
```

These are the equivalents of primitive arrays such as `int[]`.

##### More, different ways of creating arrays

There are a couple more notable ways of creating arrays quickly, without having to list all of the initial elements. One of them is the following `Array` constructor:

```kotlin
public inline constructor(size: Int, init: (Int) -> T)
```

This takes the size of the array to create, and then a lambda, which will create the element of the array for the given index. For example, if we wanted an array that contained the numbers 0 to 99, as strings:

```kotlin
val numbers: Array<String> = Array(100) { i -> i.toString() }
```

Why can't you initialize the array just with a size? You can certainly do so in Java:

```java
String[] strings = new String[200];
```

An array like that contains all `null` values in Java when created. This can't be done for an `Array<String>` in Kotlin. It's guaranteed that all of its elements are non-null `String` instances! On the other hand, you can create an `Array<String?>` very quickly, using `arrayOfNulls`:

```kotlin
val strings: Array<String?> = arrayOfNulls(200)
```

>Note the difference between `Array<String?>` and `Array<String>?`. In the former case, you definitely have an `Array` reference, and any of its elements may be `null`. With the latter, you may or may not have an `Array` reference, but if you do, it contains non-null `String` instances only. Of course, there's also `Array<String?>?`, which you can surely figure out from here.

There *is* one case where you can you allocate an array just by specifying its size - for primitive arrays. In this case, you can use a constructor that takes just a single parameter:

```kotlin
val x = IntArray(20)
```

All the elements of this array will be initialized to `0`.

##### Interactions with varargs

TODO

### Collection processing

TODO

### Sequences

TODO always. benchmark.
https://typealias.com/guides/kotlin-sequences-illustrated-guide/
http://talkingkotlin.com/sequences-with-david-leeds/