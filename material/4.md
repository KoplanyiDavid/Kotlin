# Chapter 4: Functional Programming

In chapter  2, we've looked at Kotlin's support for object oriented programming. The other major paradigm that Kotlin supports is *functional programming*.

Some general aims of functional programming are:

- Functions as a first-class citizens
  - In most OO focused languages, [functions are inferior to classes](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html). They can not exist outside of a class, they are just parts of classes - the larger, more important concept.
  - In functional programming, functions can exist on their own (remember [C](https://en.wikipedia.org/wiki/C_(programming_language)), which didn't even have classes?).
- Pure functions
  - A function is considered pure if it doesn't depend on anything but its parameters, and produces no side effects. Methods in OO are rarely pure. Most of them make use of state inside classes, and modify that state.
  - Pure functions have many advantages, the most important one of which is perhaps *referential transparency*, which means that they always produce the same results for the same inputs. This makes it very easy to reason about them, as well as to test these functions.
- Immutability
  - Mutable state is the enemy of functional programming, for good reason. The more mutable state, the more complex the code. Therefore, functional programming prefers immutable data structures and variables over mutable ones.
  - We've already seen how Kotlin promotes these ideas with its preference of `val` over `var`, and the `copy` method generated for data classes. We'll find more of the same when we get to collection types (in the next chapter).
- Declarative over imperative style
  - Instead of giving step-by-step instructions on *how* to manipulate data, functional programming focuses on *what* to do with the data.
  - This sounds rather abstract at first, but again, this is something that will be prevalent in Kotlin's collection handling.

So when can a language declare that it's functional? Does it have to meet some, or all of the requirements above? Maybe even more than these? It's very hard to say definitely. [Haskell](https://www.haskell.org/) is sometimes touted as the only true, purely functional language. However, many languages support some amount of the concepts of functional programming, which blurs the lines quite a bit.

JetBrains' stance on the matter is that they consider the support for top level functions the determining factor. This makes Kotlin a functional language, in addition to being object oriented.

## Code organization

We've seen that Kotlin has top level functions. They're what make the "hello world" program in Kotlin is as simple as this:

```kotlin
fun main() {
    println("Hello world")
}
```

Compare this to Java's "hello world":

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello world");
    }
}
```

>Just think of how many concepts you'd have to explain to someone getting started with Java to print their first message in the language. What's `public`? What's a `class`? What's `static`? What's `void`? What's a `String[]`? And so on.

So Kotlin does allow for top level functions, and you can place multiple of these in a file. In fact, you can place almost anything in a single file. Multiple functions, interfaces, public classes, and properties can all exist in one file.

These files are sorted into packages, which is declared at the top of each file. Just like classes, other top level declarations can be used in other packages by importing them.

>Unlike with Java, the packages that files reside in don't have to match the directories they're in under the source folder. There is an [official recommendation](https://kotlinlang.org/docs/reference/coding-conventions.html#directory-structure) that pure Kotlin projects should leave out the directories for the "root package" of the application, and place anything in that package directly in the root of the sources folder. However, in practice, the Java conventions are followed 99.99% of the time.

The Java language isn't what requires everything to be wrapped in classes - this is a requirement on the bytecode level. So how are all the top-level declarations in Kotlin files compiled to bytecode? There's only one possible answer: they're wrapped in classes.

For example, take this piece of Kotlin code, residing in a file called `TextUtils.kt`:

```kotlin
package util

val LOWERCASE_ALPHABET = "abcdefghijlkmnopqrstuvwxyz"

fun isEmpty(str: String?): Boolean {
    return str == null || str.length == 0
}
```

We end up with a class called `TextUtilsKt` at the bytecode level, with all static contents:

```java
public final class TextUtilsKt {
    @NotNull
    private static final String ALPHABET = "abcdefghijlkmnopqrstuvwxyz";

    @NotNull
    public static final String getALPHABET() {
        return ALPHABET;
    }

    public static final boolean isEmpty(@Nullable String str) {
        return str != null || str.length() == 0;
    }
}
```

This is good news for any Java clients, as they can access this functionality by calling static methods on a class. However, the call site is littered with the `Kt` postfix:

```java
public static void main(String[] args) {
     if (TextUtilsKt.isEmpty(args[0])) {
         // ...
     }
 }
```

Thankfully, the name of this generated class can be controlled by placing the [`@JvmName`] annotation on the entire file:

```kotlin
@file:JvmName("TextUtils")

package util

/* ... declarations ... */
```

This will have the expected effect of renaming the class to just `TextUtils`, which is much nicer to call from Java.

## Extensions

One of the often advertised, high-profile features of Kotlin are extension functions. These allow you to add new functionality to existing classes, without touching the class definition itself. This means that you can add extensions even to classes (or types, really) that you don't own.

For example, if you need a quick and easy to read way to get the last character of a `String`, you can add an extension function like this:

```kotlin
fun String.lastChar(): Char {
    return this[this.length - 1]
}

fun main() {
    println("Steve".lastChar())
}
```

Let's take a close look at this piece of code:

- The type that you're extending is marked before the name of the function, in this case, with the `String.` syntax. You're defining a function _on_ the `String` type.
- Inside the function, you can write code as if you were writing a real method inside the `String` class. The instance that your extension was called on is available as `this`. This instance is called the *receiver* inside the extension function.
- Invoking an extension has the same syntax as any real method of the class. If it's in a different package, it does have to be imported, like any other top level function would be.

So... How is this possible? Don't worry, Kotlin doesn't attempt to rewrite the bytecode of existing classes. Instead, extensions are implemented as simple static functions on the bytecode level. If we decompile the bytecode from the code above, we'll see just that:

```java
public static final char lastChar(@NotNull String $this$lastChar) {
    Intrinsics.checkParameterIsNotNull($this$lastChar, "$this$lastChar");
    return $this$lastChar.charAt($this$lastChar.length() - 1);
}

public static final void main() {
    char var0 = lastChar("Steve");
    System.out.println(var0);
}
```

The receiver of the function simply becomes the first parameter of the function, and any other parameters are shifted over by one. This implementation detail is very important, as it poses some limitations on extensions, and it explains some of their behaviour.

Since extensions aren't real members, just static functions operating on an object, they *can't access non-public API of the type that they're being added to*. This would break encapsulation. You can't implement anything with an extension that you couldn't implement in a function that takes the receiver as a parameter - you just get much nicer syntax.

As extension functions are static, they are resolved statically, which is a significant difference from how regular members work. Consider the following example:

```kotlin
abstract class Animal {
    open fun identify() {
        println("This is an animal.")
    }
}

class Cat : Animal() {
    override fun identify() {
        println("This is a cat!")
    }
}

fun main() {
    val animal: Animal = Cat()
    animal.identify() // This is a cat!
}
```

Even though we are holding onto a reference of a `Cat` as an `Animal`, when we call its `identify` method, the method defined in the `Cat` class is invoked. This feature - dynamic dispatch - is the basis of polymorphism, a core concept of object oriented programming. It allows for the implementation to be invoked to be chosen at runtime.

So what happens if we move both of these `identify` methods into extensions instead?

```kotlin
abstract class Animal

fun Animal.identify() {
    println("This is an animal.")
}

class Cat : Animal()

fun Cat.identify() {
    println("This is a cat!")
}

fun main() {
    val animal: Animal = Cat()
    animal.identify() // This is an animal.
}
```

We suddenly lose dynamic dispatch. Since the `identify` functions are static, the decision about which one to call has to be made at compile time. At that time, all we know for certain is that we have an `Animal` instance. Any concrete `Animal` can end up in that reference by the time we have to call `identify` at runtime.

---

Extensions are a powerful tool that let you add missing functionality to types, and make existing, awkward APIs easier to use when you write Kotlin code. The Android ecosystem, for example, has [first-party](https://developer.android.com/kotlin/ktx) libraries containing nothing but extensions around existing API.

For example, showing a quick message called a [Toast](https://developer.android.com/guide/topics/ui/notifiers/toasts) on-screen requires you to use this API, which requires you to pass in a `Context` object as the first parameter, a length as the last one, and then _not forget to call `show`_ after creating the `Toast`.

```kotlin
Toast.makeText(this, "Network timed out", Toast.LENGTH_SHORT).show()
```

This can be very easily be wrapped up in an extension which is effortless to call when you're inside a class that's a `Context` itself:

```kotlin
fun Context.toast(message: String, duration: Int = Toast.LENGTH_SHORT) {
    Toast.makeText(this, message, duration).show()
}

toast("Network timed out")
```

Note the use of the default parameter value, which allows you to provide fewer parameters in the common case, but still gives you the ability to customize the value, should you need to.

### Extension oriented design

A significant amount of the functions in the standard library are defined as extensions. Many of them extend commonly used classes, such as `String` or `File`. We'll take a closer look at these extensions later.

However, many functions that operate on standard library types (which could be easily just added inside the class body) are also defined in extensions. This allows the classes to contain just the core, essential functionality that they need. Everything else can be defined as extensions, which are loosely coupled to the class, allowing it to easily change later.

For example, take this `Node` class that can be used to build a binary tree:

```kotlin
class Node(val value: Int) {
    var leftChild: Node? = null
    var rightChild: Node? = null

    fun traverse() {
        leftChild?.traverse()
        println(value)
        rightChild?.traverse()
    }
}
```

Its `traverse` member doesn't _really_ belong in this class. Traversing is not something a `Node` can do, it's a way that we use a `Node`. The class itself can easily be just a data holder, which doesn't have any behaviour.

>This member function also prevents anyone from adding their own function named `traverse` as an extension, which might not be desirable. Members always take precedence over extensions.

Instead of this function living inside `Node`, we can provide it as an extension:

```kotlin
class Node(val value: Int) {
    var leftChild: Node? = null
    var rightChild: Node? = null
}

fun Node.traverse() {
    leftChild?.traverse()
    println(value)
    rightChild?.traverse()
}
```

This allows other developers to define their own `traverse` extensions in different packages, which may perform a different kind of traversal (e.g. pre-order).

>What happens if you need to use multiple extensions with the same name in the same file? You have to [get a bit creative with your imports](https://stackoverflow.com/a/42753052/4465208). You can use the `import com.myutils.traverse as traverseInOrder` syntax to rename any imported symbol for a given file. This lets you resolve extension clashes, and it's also useful if you want to conveniently use multiple classes with the same name, without having to fully qualify one of them everywhere in a file.

This pattern is referred to as [*extension oriented design*](https://medium.com/@elizarov/extension-oriented-design-13f4f27deaee). It's prevalent in many first-party Kotlin libraries, for example in the standard library's collection processing functions, sequences, and coroutines.

### Extension properties

Extension properties are much the same as extension functions under the hood, but they come with the regular property syntax. *They may only be "computed" properties, because to store data, the original class would have to be modified.*

As an example of an extension property, let's add a `bd` property to the `Int` type, to quickly and easily create `BigDecimal` instances:

```kotlin
val Int.bd: BigDecimal
    get() = BigDecimal(this)
    
val thousand: BigDecimal = 1000.bd
println(thousand)
```

Inside the getters and setters of these properties, the current instance is available as `this`, as you might expect.

### Member extensions

Extensions may also be declared *inside a class* (or interface) as a member. In these cases, the extensions become quite different from other, top-level extensions.

They will have two receivers available as `this`. The *dispatch receiver*, which is the instance of the enclosing class, and the *extension receiver*, the instance of whatever type the extension was defined on. In ambiguous cases, the extension receiver will take precedence:

```kotlin
class Queue(val length: Int) {
    fun String.process() {
        println(length) // String's length
        println(this.length) // String's length
        println(this@Queue.length) // Queue's length
    }
}
```

The dispatch receiver can be accessed with a [qualified `this`](https://kotlinlang.org/docs/reference/this-expressions.html#qualified), which is also used when choosing from multiple implicit receivers in other situations, such as in nested classes.

These extensions are *not* static, instead, they are regular member functions under the hood. This means that overriding and dynamic dispatch *does* happen, although not by the type that is extended, but by the containing type.

This means that you can make these extensions `open` or `abstract`, and force subtypes to implement them:

```kotlin
abstract class Validator {
    abstract fun String.isValid(): Boolean

    fun validate(str: String?): Boolean {
        return str != null && str.isValid()
    }
}

class EmailValidator : Validator() {
    override fun String.isValid(): Boolean {
        return this.contains('@')
    }
}
```

While this is technically possible, it's often simpler to use regular functions that take the receiver as an explicit parameter.

There _are_ valid use cases for these types of extensions. These declarations are only visible within the class that they're declared in, which is a way of scoping extensions that won't be widely used in a project.

However, they also come with some surprising behaviour, which can be avoided by using private, top-level extensions, or even function-local extensions instead, if applicable.

## Function types

Other than supporting top-level, standalone functions, perhaps the most important functional aspect of Kotlin is its support for function types.

Take this class and this function for example:

```kotlin
data class Person(val name: String, val age: Int)

fun getAge(person: Person): Int {
    return person.age
}
```

This function takes a `Person` parameter, and returns an `Int`. The type of this function is `(Person) -> Int`. The function type that takes no parameters and returns no value would be `() -> Unit`. A function that adds two whole numbers together could have the type `(Int, Int) -> Int`.

Variables can have these function types in Kotlin. If we wanted to store the function above in a variable, we could either store a reference to it:

```kotlin
val ageGetter: (Person) -> Int = ::getAge
```

Or declare the entire function in-line, and assign it to a variable immediately (this is very, very rarely used):

```kotlin
val ageGetter: (Person) -> Int = fun(person: Person): Int {
    return person.age
}
```

Functions can be invoked from references the same way as usual, with the `()` syntax, passing in any parameters:

```kotlin
val julie = Person("Julie", 36)
println(ageGetter(julie)) // 36
```

### Lambdas

Instead of declaring anonymous functions with the full function syntax and the `fun` keyword, we can use function literals, or *lambdas*. The previously seen `ageGetter` function could be implemented in a lambda like this:

```kotlin
val ageGetter = { person: Person -> person.age }
```

This variable still has the same type as before, but we are now letting the compiler infer it based on the expression on the right hand side.

Lambdas may contain multiple expressions, and they implicitly return their last expression, without a `return` keyword:

```kotlin
val ageGetter = { person: Person ->
    println("Getting the age of ${person.name}...")
    person.age 
}
```

This function, now defined as a lambda, can still be invoked the same way as before:

```kotlin
val julie = Person("Julie", 36)
println(ageGetter(julie)) // 36
```

If we do provide the type on the left hand side, we can omit the type of the lambda's parameter, and let inference work the other way:

```kotlin
val ageGetter: (Person) -> Int = { person -> person.age }
```

For lambdas that have *only a single parameter*, one final simplification may be performed - we can skip naming the parameter altogether. In this case, it will be available via the implicit name `it`:

```kotlin
val ageGetter: (Person) -> Int = { it.age }
```

>It's common to see long, complex lambdas use this implicit `it` name for their parameter. Be wary of doing this - naming the parameter can go a long way towards increasing readability and avoiding mistakes of operating on the wrong object. A good rule of thumb is to use an explicit name when your lambda doesn't fit on a single line.

### Bound references

We've seen references to top level functions. You can also reference methods of a specific class, and then invoke them by passing in a concrete instance:

```kotlin
class Person(val name: String) {
    fun speak() {
        println("Hi, I'm $name!")
    }
}

val speak: (Person) -> Unit = Person::speak
val grace = Person("Grace")
val rebecca = Person("Rebecca")
speak(grace) // "Hi, I'm Grace!"
speak(rebecca) // "Hi, I'm Rebecca!"
```

References may also be bound to a specific instance, for example:

```kotlin
val claudia = Person("Claudia")
val speak: () -> Unit = claudia::speak
speak() // "Hi, I'm Claudia!"
```

Dealing with these method references skirts the boundaries of Kotlin's reflection features, which we'll explore later on.

>To explore a bit, take a look at what the inferred types of these references would be if we didn't type them explicitly.

## Higher order functions

### Introduction

A function that takes another function as a parameter or returns a function is called a *higher order function*.

Kotlin has support for function types, and we've seen how we can store functions in variables. Passing them in and out of functions is a small step up from here technically, but it will open up a whole new world of possibilities.

Let's start with one of the simplest of higher order functions, one that executes the function (i.e. a given piece of code) passed to it:

```kotlin
fun execute(actions: () -> Unit) {
    actions()
}

execute({ println("Hello world") }) // Hello world
```

Calling the function passed in just once is the simplest thing to do. We could also store this function, `actions` - which really is just a piece of code at the call site - and we could invoke it at any later point in time.

Or we could introduce a new parameter, and call it repeatedly - we'll also rename our function, which does more than just execute the parameter now.

```kotlin
fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

repeat(3, { println("Hello world") })
```

At this point, the IDE is screaming at us with a warning, suggesting that we change our code style. Whenever a function's last parameter is a function type, and that parameter is being fulfilled by a lambda, that lambda can be moved outside the parentheses of the parameter list:

```kotlin
repeat(3) { println("Hello world") }
```

If we reformat this a bit with some newlines, our `repeat` function will start looking *a lot* like a built-in language construct...

```kotlin
repeat(3) {
    println("Hello world") 
}
```

### FunctionX types

We've seen that with function types, we can assign functions to variables, and even pass them around - a lot of possibilities open up in front of us. How does this work under the hood?

Kotlin functions on the JVM are implemented as anonymous classes, which implement certain interfaces. For example, the `Function0` interface is used for functions that take no parameters. For single-parameter functions, there's a `Function1` type. And so on, and so on. Here's the declaration of these two interfaces, *simplified*:

```kotlin
interface Function0<R> {
    fun invoke(): R
}

interface Function1<P1, R> {
    fun invoke(p1: P1): R
}
```

>These `FunctionX` types only go up to `Function23`, but the upper limit for the number of function parameters is 255 on the JVM. Try to find out what happens with functions that have more than 23 parameters!

These functional interfaces - such as `Function1` - all require just a single `invoke` method, which will have a signature that corresponds to their function type, and its body will contain the body of the function in whatever class implements it.

Creating instances of interfaces like these, storing references to them, and calling methods on them are very basic things that you could do in Java as well - Kotlin just provides all the syntactic sugar for doing it conveniently.

In fact, let's call our `repeat` function from Java, to see how we can create the `Function0` it requires as a parameter by hand.

```java
repeat(3, new Function0<Unit>() {
    public Unit invoke() {
        System.out.println("Hello world");
        return Unit.INSTANCE;
    }
});
```

`Unit`, the generic parameter of `Function0`, is the return type of this no-parameter function type.

>`Unit`-returning functions, and especially lambdas, are inconvenient in Java, as you have to explicitly return `Unit.INSTANCE`, unlike with `void` methods, where you can simply omit the return statement.

### Optimizations

Let's go back to our previous call from Kotlin that we've made to this same `repeat` function:

```kotlin
repeat(3) { println("Hello world") }
```

... and see what it decompiles to. We expect to see basically the same code as we've just written in Java, however...

```java
repeat(3, (Function0)null.INSTANCE);
```

It turns out the built-in decompiler isn't able to handle this code. This is a good example of things that it simply can't deal with right now. If we use a better decompiler (such as [jadx](https://github.com/skylot/jadx)), we'll quickly discover what's going on:

```java
final class HelloKt$example$1 implements Function0 {
    public static final HelloKt$example$1 INSTANCE =
    new HelloKt$example$1();
    
    public final void invoke() {
        String str = "Hello world";
        System.out.println(str);
    }
}
```

There was a class generated which implements `Function0` and prints `"Hello world"` in its `invoke` method, as expected. It also contains an extra member: a static instance of itself!

Since this lambda relies on no external values or parameters in its `invoke` method, the compiler optimizes it into a singleton, so that only a single instance of it is ever created and used over the lifetime of our program.

`null.INSTANCE` in the decompiler output, then, is just a read to this static field to get the instance, except the decompiler didn't manage to resolve the classname for some reason. What we should see here is this:

```java
repeat(20, (Function0) HelloKt$example$1.INSTANCE);
```

### Capturing values

We've seen what happens when a lambda relies on no external values. This often isn't the case though. Lambdas act as [closures](https://en.wikipedia.org/wiki/Closure_(computer_programming)), which means they will capture any variables from outer scopes that are referenced inside them.

Take for example this extension, which "multiplies" a string, making use of our existing `repeat` method:

```kotlin
fun String.multiply(times: Int): String {
    var result = ""
    repeat(times) {
        result += this
    }
    return result
}
```

The lambda being passed in to `repeat` here reads *and modifies* the `result` variable from an outer scope.

We can imagine capturing a variable with an anonymous class in Java as well - the requirement for this is that the reference being captured needs to be *final*:

```java
public static String multiply(final String $this, int times) {
    final String result = "";
    repeat(3, new Function0<Unit>() {
        public void invoke() {
            result = result + $this; // e: Cannot assign a value to final variable 'result' 
            return Unit.INSTANCE;
        }
    });
    return result;
}
```

However, modifying this `String` is another story. Since we can't change what the `result` reference points to, we'd need to modify the object it points to... But the `String` type on the JVM is immutable.

So that's our catch-22 here: we need the reference to be final so that we can capture it, but we also need it to be mutable so that we can assign newly created `String` instances to it. In Java, this might seem unsolvable. In Kotlin, it compiles and works as expected.

What's happening under the hood? Let's decompile!

```java
@NotNull
public static String multiply(@NotNull final String $this$multiply, int times) {
    Intrinsics.checkParameterIsNotNull($this$multiply, "$this$multiply");
    final ObjectRef<String> result = new ObjectRef(); // 1
    result.element = ""; // 2
    repeat(times, new Function0() {
        public final void invoke() {
            ObjectRef var10000 = result; // 3
            String var10001 = var10000.element;
            var10000.element = var10001 + $this$multiply;
        }
    });
    return result.element; // 4
}
```

1. There's an instance of the `ObjectRef` class being created. This class is just a wrapper around a generic value (its definition here is slightly simplified):

    ```java
    public class ObjectRef<T> {
        public T element;
    }
    ```
    
    This reference to the `ObjectRef` instance is *final*, so it can be captured by an inner class.

2. The empty `String` instance we start with is stored in the *mutable* reference inside the `ObjectRef`.
3. Inside the lambda, the current `String` instance is removed from the `ObjectRef`, concatenation happens, and then the new `String` instance is placed in the `ObjectRef`.
4. Whatever reference ends up being in the `ObjectRef` by the time the method reaches its last line is returned.

`ObjectRef` is one of several wrappers that can provide an extra level of indirection in the bytecode to allow capturing mutable references. This one is used for reference types, such as `String`. An additional wrapper just like it exists for each primitive type for performance reasons - [see them all here](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/Ref.java).

This isn't a type you need to use yourself - the Kotlin compiler will deploy it as necessary when you capture values from outer scopes that you want to mutate. However, it's good to know that this happens, as it might cause memory leaks if you're not careful. If you're writing Java code, you can make use of this pattern manually, to solve similar problems.

### Inline functions

Passing around lambdas is simple, convenient, and it allows for powerful abstractions that we'll see great examples of when we discuss collections. However, the previous example shows that we pay a price when passing in lambdas to functions. Each lambda will cost an object allocation, and capturing references can also lead to further allocations.

Let's be greedy. What if we could have our cake and eat it too? What if we could get these abstractions for "free", with no runtime performance hit?

This is where *inline functions* come to the rescue. Their name describes what they are fairly well. They are functions that get *inlined* to wherever they're called from. For the simplest example, take the following `greet` method, and the call to it in `main`:

```kotlin
inline fun greet(name: String) {
    println("Hello, $name!")
}

fun main() {
    greet("Abby") // Hello, Abby!
}
```

Decompiling the `main` function, you'd usually expect to see just one line, the call to `greet`. Instead, you'll see this:

```java
public static final void main() {
    String name$iv = "Abby";
    String var2 = "Hello, " + name$iv + '!';
    System.out.println(var2);
}
```

The entire body of the `greet` function has been "copy-pasted" to the call site, with any parameters substituted as well. This is what inlining does.

With a function as simple as this, the IDE will warn us that the gains from inlining the method won't be very significant, as function calls are not too expensive in general. It's up to you to decide in each case whether inlining a certain function is worth it.

>If you have a very long, complex function, inlining might not be the best idea. Every time you call it, its contents will be injected to the call site, bloating your compilation output.

Where inlining is definitely useful and often recommended is with higher order functions, as it can get rid of our lambda allocations. Just like parameters are substituted into the inlined function body, so are the contents of lambdas that are called inside the function being inlined. That sounds complex, but let's take a look at it in practice.

Taking our previous example of `multiply`, and adding the `inline` modifier to `repeat`:

```kotlin
inline fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

fun String.multiply(times: Int): String {
    var result = ""
    repeat(times) {
        result += this
    }
    return result
}
```

After decompiling, there's no call to `repeat` anymore. The loop from that function body simply exists directly in the `multiply` method, as if we've written it ourselves right there:

```java
@NotNull
public static String multiply(@NotNull String $this$multiply, int times) {
    Intrinsics.checkParameterIsNotNull($this$multiply, "$this$multiply");
    String result = "";
    int var4 = 0;
    for (int var5 = times; var4 < var5; ++var4) {
        result = result + $this$multiply;
    }
    return result;
}
```

Inlining is most often used with higher order functions, where there is a very clear performance gain. Another good use case is when wrapping existing, difficult to use APIs with extensions. By inlining your wrappers, the bytecode produced is _exactly_ the same as if you've written the code the complex way (no extra call to a static helper function), but your source can be simpler thanks to your extensions. Free abstraction!

##### Non-local returns

Return statements inside lambdas can get quite complicated. Take the example where we want to `return` inside the `repeat` function on some condition:

```kotlin
fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

fun test() {
    repeat(10) {
        if (Random.nextDouble() > 0.6) {
            println("Failure")
            return
        }
        println("Success")
    }
}
```

You might expect this `return` to return within the lambda, and to skip just a single iteration of the loop. This is not the case. The rule for a `return` statement is that by default, it always returns from the closest `fun`. In this case, this would be the `test` function.

Such a return inside this lambda isn't allowed, as the `repeat` function could do many things with its parameter - for example, store it and invoke it later. In those invocations, the lambda containing a `return` from `test` wouldn't make any sense!

>The closest `fun` rule means that there's a difference between anonymous functions declared with `fun() {}` and function literals declared with `{}` when it comes to returns!

So how do we return from just a single iteration of the lambda? We have to qualify the `return` statement with the scope that we want to return from:

```kotlin
fun test() {
    repeat(10) {
        if (Random.nextDouble() > 0.6) {
            println("Failure")
            return@repeat
        }
        println("Success")
    }
}
```

What about the other case, can we somehow return from the `test` function from inside a lambda? The solution for this is to inline the `repeat` function. This way, we know that the lambda we pass to it will only be executed in place, in the context of the `test` function. This will let us compile our original code above, and cancel `repeat` altogether on the first failure.

##### noinline and crossinline

Some special cases around inlining have to be quickly mentioned here.

When you inline a function, by default, all of its lambda parameters will be inlined. You can use `noinline` to mark any lambda parameters that you _don't_ want to be inlined - instead, they'll be passed in the regular way, with a function object being allocated for them. This will prevent you from using non-local returns in these lambdas, but allow you to, for example, store them in properties for later use.

>TL;DR: `noinline` prevents the inlining of a given parameter with a function type, and passes it in the regular way, like to any non-inline function.

A slightly more complex use case is when you're passing in a lambda somewhere and you want it inlined, but you can't allow non-local returns from it, as it doesn't make sense in the execution context. For example, here, `body` would be inlined inside the `run` function's body. At the call site, since we're in an inline function, we'd expect to be able to use `return` freely to return from `test`, but the `Runnable` that's being created has no context of the `test` method, and couldn't perform a return from it.

```kotlin
inline fun funky(body: () -> Unit) {
    val runnable = object: Runnable {
        override fun run() { 
            body()
        }
    }
    runnable.run()
}

fun test() {
    funky {
        println("This is really quite complicated!")
    }
}
```

We could solve this by marking `body` with `noinline`, but then we'd suffer an object allocation, and inside `run`, we'd see something like this after compilation:

```java
new Runnable() {
    public void run() {
        body$iv.invoke();
    }
};
```

We can use `crossinline` instead, which will still inline the lambda (inside the `run` method of the `Runnable` being created), but prevent non-local returns from being used inside it. This fixes our context issues, and still saves us the allocation:

```java
public static void test() {
    Runnable runnable = new Runnable() {
        public void run() {
            String var2 = "This is really quite complicated!";
            System.out.println(var2);
        }
    }
    runnable.run();
}
```

>TL;DR: `crossinline` disables non-local returns in a parameter with a function type, removing some limitations on how you may use it.

In general, you don't need to worry about remembering the exact mechanics of `noinline` and `crossinline`, as they are rarely used. But it's useful to know they exist so that you can look them up as needed. When you get into the special situations that require them while writing your own code, your IDE will most likely suggest adding them automatically.

### Typealiases

Typealiases let you rename types. As their name says, they don't create new types, just aliases for existing ones. This can come in handy when you want to rename a type for local use (similarly to renaming an imported symbol, but not just for a single file), and they are perhaps most often used to give semantics to function types.

Take the example of a `View` interface that allows you to register a click listener:

```kotlin
interface View {
    fun setOnClickListener(listener: () -> Unit)
}
```

Instead of the regular function type of `() -> Unit`, you may choose to be more expressive, and use a typealias for this parameter:

```kotlin
typealias OnClickListener = () -> Unit

interface View {
    fun setOnClickListener(listener: OnClickListener)
}
```

These two types will be cross-compatible. You can assign an `OnClickListener` to something with the type `() -> Unit` and vice versa, because they *are* the same type.

>We'll eventually take a look at *inline classes*, which are quite similar, but do introduce distinct, new types.

### SAM conversion, SAM constructor

On the topic of function types, one of Kotlin's primary Java interop features has to be mentioned. We've seen the `FunctionX` interfaces in Kotlin, which served the sole purpose of wrapping a block of code in a class instance, with their single `invoke` method.

Modern Java versions support lambdas as well, but lack truly standard function types, so many libraries introduce their own (in addition to the many that are included in the platform, such as [`Predicate`](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html) or [`BiFunction`](https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html)). You are encouraged to create your own as well, and mark it with [`@FunctionalInterface`](https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html), indicating that it's supposed to be used in a functional manner, often instantiated with lambda syntax.

The requirement for a functional interface is simple: have a single method that you require to be implemented. These are often also called Single Abstract Method (SAM) interfaces.

Kotlin supports passing in lambdas and functional types as parameters where an implementation of a Java-declared functional interface is expected. For example, given this Java code:

```java
interface View {
    interface OnClickListener {
        void onClick(View view);
    }

    void setOnClickListener(OnClickListener listener);
}
```

The way to pass in an instance of `OnClickListener` in Kotlin would be to create a separate class that implements the interface and instantiate it, or to use an `object` expression:

```kotlin
view.setOnClickListener(object: View.OnClickListener {
    override fun onClick(view: View) {
        println("Clicked!")
    }
})
```

This is a lot of code for just the single line print statement that we're trying to pass in here. Using *SAM conversion*, we can pass in a lambda that matches the signature of the single method in the interface, in this case, one that has the type `(View) -> Unit`:

```kotlin
view.setOnClickListener { 
    println("Clicked!") 
}
```

This feature, [for](https://youtrack.jetbrains.com/issue/KT-7770) [now](https://youtrack.jetbrains.com/issue/KT-11129), only works when the interface is declared in Java, as well as the method taking it as a parameter. SAM conversions for Kotlin-declared interfaces is not possible at all (the reasoning being that you could just use function types in Kotlin). When the interface is declared in Java, but the method is written in Kotlin, or when the conversion would be ambiguous due to overloads, the slightly more verbose *SAM constructor* syntax may be used:

```kotlin
view.setOnClickListener(View.OnClickListener {
    println("Clicked!")
})
```

>One drawback of SAM conversions is that inside the lambda being passed in, there is no `this` reference to the lambda instance. If you need this reference (for example, for a listener to unregister itself in certain cases), you'll have to use the full object expression syntax.

# Summary

One of Kotlin's most advertised features is extensions, which allow you add new functionality onto existing types, even ones that you don't own yourself.

Functions are first-class citizens, just like classes or objects. They can be declared as top level constructs in a file, and imported individually. Function types are a core part of the language, and they allow functions to be stored in variables, or passed around as parameters. Lambda expressions (function literals) are a concise way to define functions, especially if you're immediately passing them in as parameters.

Functions that take functions as parameters or return functions are called higher order functions. The cost of passing function parameters to them (implemented as instances of classes under the hood) can be mitigated by making them inline. In certain situations, `noinline` and `crossinline` can come in handy.

Finally, Kotlin provides SAM conversion and SAM constructors as a way to interop with functional interfaces that are declared in Java code.

# Sources

- Official documentation:
  - [Extensions](https://kotlinlang.org/docs/reference/extensions.html)
  - [Higher-Order Functions and Lambdas](https://kotlinlang.org/docs/reference/lambdas.html)
  - [Inline functions](https://kotlinlang.org/docs/reference/inline-functions.html)
  - [Type aliases](https://kotlinlang.org/docs/reference/type-aliases.html)
  - [SAM Conversions](https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions)
- [jadx - Dex to Java decompiler](https://github.com/skylot/jadx)
