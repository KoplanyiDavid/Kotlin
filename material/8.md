# Chapter 8: Operators, Conventions, and Delegates

Like many other modern languages, Kotlin supports operator overloading. Unlike some other languages, it doesn't let you define any arbitrary symbols as operators, but instead, it confines you to a predefined set of operators that you may define for each type.

Building on its operator semantics, the language also has a set of conventions that let you implement your own classes in ways that make them as convenient to use as first-party constructs, such as the `List` or `Array` types.

## Operators

### Simple operators

We'll need a type that we study operators on. Our example will mimic some of the behaviour of a built-in type: an `Int`. We'll do this in a very simple way, by wrapping an actual `Int` value with our class.

For a start, we'll define a constructor that stores this value, and two utility methods, which let us access the stored value as an `Int` and as a `String`:

```kotlin
class MyInt(private val value: Int) {
    fun toInt(): Int = value
    override fun toString() = value.toString()
}
```

What can we do if we want to add two `MyInt` instances together? We can define a method for it. This method will create a new `MyInt` instance, containing the result.

```kotlin
class MyInt(private val value: Int) {
    // ...
    fun add(other: MyInt): MyInt {
        return MyInt(this.value + other.value)
    }
}
```

We can then create instances of `MyInt`, add them up, and print this result (which invokes `toString`, giving us the value as a `String`):

```kotlin
val a = MyInt(4)
val b = MyInt(8)
println(a.add(b)) // 12
```

This, of course, works as expected. But what we really want to be able to do is use the operators that built-in types are using with our very own types:

```kotlin
println(a + b)
```

The key to this in Kotlin is the `operator` keyword. This lets you define every operator present in the language (`+`, `-`, `%`, and so on) for your own types. You can not create operators with arbitrary symbols, you can only work with the predefined set.

To define these operators, you need a function that's marked with the `operator` keyword, and it needs to have a specific name that corresponds to an operator. You can find the mapping between the operator symbols and their function names [in the official documentation](https://kotlinlang.org/docs/reference/operator-overloading.html).

The mapping between the method names and the syntax of each operator has semantic importance. You should only use operators for cases where calling the functions with their regular syntax would be appropriate to use as well. For example, don't define a `plus` method that doesn't add things together. After all, these are just functions, and they can still be invoked with the regular function call syntax at any time.

>This is also an item in Effective Kotlin: *Item 12: Operator meaning should be consistent with its function name*.

For our purposes of a `+` operator, we'll need to define the `plus` function, marked as an `operator`:

```kotlin
operator fun plus(other: MyInt): MyInt {
    return MyInt(this.value + other.value)
}
```

The `plus` method has to be either a member or an extension on a type, and it has to take a single parameter. These are fixed requirements, since it's a binary operator.

There are no specific requirements for the types used in the method signature though. While this function takes another `MyInt` instance as its parameter, and returns `MyInt`, most Kotlin operators let you vary these types arbitrarily. You could define another `plus` method that takes a `String` as a parameter and returns a `Double`, or a `Cow`, or even `Unit` if you wanted to.

>There *are* a few operators that have required return types, such as `Boolean`, because they're used in specific situations.

This was a binary operator, but the language also has unary operators, which are applied to just a single value. For example, the unary minus operator, which negates a number (or gives you its additive inverse, if you're feeling fancy).

As already mentioned, operators don't have to be defined as members, they can also be extensions on a type (as long as they don't need to access private members):

```kotlin
operator fun MyInt.unaryMinus(): MyInt {
    return MyInt(-this.toInt())
}
```

This operator can then be used for your custom type just like it's used on the built-in types, by prefixing them with it:

```kotlin
println(-MyInt(4)) // -4
```

Thanks to the ability of defining operators as extensions, the Kotlin Standard Library ships operators for many built-in types, without modifying them. Some examples of these are the [`java.math.BigDecimal`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/java.math.-big-decimal/index.html) and [`java.math.BigInteger`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/java.math.-big-integer/index.html) extensions, as well as the [`plus`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/plus.html) and [`minus`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/minus.html) operators that are defined for many, many collection types.

These let you transform code like this...

```kotin
fun solve(
    a: BigDecimal, b: BigDecimal, c: BigDecimal
): Pair<BigDecimal, BigDecimal> {
    val sqrtD = b.multiply(b).subtract(BigDecimal(4).multiply(a).multiply(c)).sqrt(MathContext.UNLIMITED)
    val x1 = b.negate().add(sqrtD).divide(BigDecimal(2).multiply(a))
    val x2 = b.negate().subtract(sqrtD).divide(BigDecimal(2).multiply(a))
    return Pair(x1, x2)
}
```

... into code like this:

```kotlin
fun solve(
        a: BigDecimal, b: BigDecimal, c: BigDecimal
): Pair<BigDecimal, BigDecimal> {
    val sqrtD = sqrt(b * b - 4.toBigDecimal() * a * c)
    val x1 = (-b + sqrtD) / 2.toBigDecimal() * a
    val x2 = (-b - sqrtD) / 2.toBigDecimal() * a
    return Pair(x1, x2)
}
```

The `.bd` extension property we've seen in chapter 4 would make this code even cleaner.

>The  [`BigDecimal#sqrt`](https://docs.oracle.com/javase/9/docs/api/java/math/BigDecimal.html#sqrt-java.math.MathContext-) method is only available from Java 9, and you'd have to define your own top level `sqrt` function that wraps it for the syntax seen above.

>This is **not** a proper implementation of a quadratic equation solver. Write a better one yourself!

### Getting and setting

You might have noticed that the "indexing" syntax that we use when accessing elements in an array also works for other collections in Kotlin, for example, for the `List` types:

```kotlin
val numbers = mutableListOf(3, 5, 1, 6, 7, 2)
println(numbers[3])
numbers[4] = 8
```

These, again, are a pair of operators: the [`get`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/get.html) and [`set`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set.html) operators.

You can define these for your own types as well, and as they're just functions, you can place any code inside them. For example, you can have a `Vector3`  class, which stores its data as `x`, `y`, and `z` properties internally, but exposes these components through `Int` indices.

```kotlin
data class Vector3(var x: Int, var y: Int, var z: Int) {
    operator fun get(index: Int): Int {
        return when (index) {
            0 -> x
            1 -> y
            2 -> z
            else -> throw IllegalArgumentException("Invalid index")
        }
    }

    operator fun set(index: Int, value: Int) {
        when (index) {
            0 -> x = value
            1 -> y = value
            2 -> z = value
            else -> throw IllegalArgumentException("Invalid index")
        }
    }
}
```

You could then use a `Vector3` instance like this:

```kotlin
val v = Vector3(0, 0, 0)
v[2] = 42
v[0] = 169
println(v[2]) // 42
println(v) // Vector3(x=169, y=0, z=42)
```

>You can define an arbitrary number of parameters for these operators. For example, for a `Matrix` type, you could achieve syntax like `mx[4, 1] = 20`, with a 3-parameter `set` method. All but the last parameter of the `set` operator have to be provided between the brackets.

### Invoke

A special case of operators is the `invoke` operator, which lets you use the function call syntax on the type that it's defined for. We've already encountered this operator for the `Function` types in the Kotlin runtime, [back in chapter 4](./4.md#function-x-types):

```kotlin
interface Function0<R> {
    operator fun invoke(): R
}
```

This is why a `Function0` instance - which is anything with a function type that takes no parameters, such as `() -> Unit` - can be called as a function.

We can also use `invoke` in our own types if it makes sense. For example, if you're using the [command pattern](https://en.wikipedia.org/wiki/Command_pattern), you might define an interface like this:

```kotlin
interface Command {
    operator fun invoke()
}
```

As an example, you could write a command that can copy a file, implemented as simply as using [`copyTo`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/copy-to.html):

```kotlin
class CopyCommand(
        private val source: File,
        private val target: File
) : Command {
    override fun invoke() {
        source.copyTo(target)
    }
}
```

You can invoke a command like this by calling its `invoke` method as a function, or using its operator form:

```kotlin
val command: Command = CopyCommand(File("current.txt"), File("archived.txt"))
command.invoke()
command()
```

### Equality and comparisons

Let's talk about equality - without the politics. We'll stick to what we know, operators. The `MyInt` class we've defined currently fails basic equality checks, that two regular `Int` instances would pass successfully:

```kotlin
val x = MyInt(10)
val y = MyInt(10)
println(x == y) // false
```

Although Java uses `==` to compare *references*, that's not what happens in Kotlin with this operator. Instead, it translates to a call of the `equals` method, [defined in `Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/equals.html). This is done because this is the comparison we want to perform in our applications a vast majority of the time.

>How do you perform a comparison of references, if `==` is just an `equals` call? With the `===` and `!==` operators.

Since we don't have an `equals` method defined for `MyInt`, we fall back to its default implementation in `Any`, which is mapped to `java.lang.Object`. [The documentation](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-) in that class states the following: *"for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true)"*. Due to the lack of an `equals` implementation, we've fallen back to comparing references, which fails.

One approach to get an `equals` implementation quickly would be to make our `MyInt` class a data class, which wouldn't be unreasonable, however, we'll write an `equals` method manually instead:

```kotlin
override fun equals(other: Any?): Boolean {
    if (other !is MyInt)
        return false
    return value == other.value
}

override fun hashCode(): Int {
    return value
}
```

>We are following age-old advice from Effective Java here: *Item 11: Always override `hashCode` when you override `equals`.*

Our `equals` implementation isn't quite perfect (compare it with what IntelliJ generates, if you want to see some potential improvements), but it's good enough for all practical purposes. Note how we're taking advantage of smart casts in it, to access `other.value`.

Implementing `equals` gives us working `==` and `!=` operators for our `MyInt` class:

```kotlin
println(MyInt(10) == MyInt(10)) // true
println(MyInt(10) == MyInt(0)) // false
println(MyInt(10) != MyInt(0)) // true
```

How about comparisons? This is provided through yet another operator, `compareTo`. This operator has to take a single parameter, and return an `Int`, the value of which follows the rules set by the [`java.lang.Comparable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html) interface. Simplified, this return should be:

- zero, if the two values are equal,
- a negative number, if the first value is smaller,
- a positive number, if the first value is larger.

Implementing this for `MyInt`, we can do this easily by subtracting the two values from each other:

```kotlin
operator fun compareTo(other: MyInt): Int {
    return this.value - other.value
}
```

Or if we get a bit cheeky, we can delegate this to the [`Int#compareTo`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/compare-to.html) function:

```kotlin
operator fun compareTo(other: MyInt): Int {
    return this.value.compareTo(other.value)
}
```

Either way, we now get to use `>`, `<`, `<=` and `>=` on `MyInt`:

```kotlin
println(MyInt(5) < MyInt(10)) // true
println(MyInt(5) > MyInt(10)) // false
```

Optionally, you can also implement the [`Comparable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparable/index.html) interface, which comes in handy in certain cases, for example, if you want to [sort](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted.html) a collection of such items. The `compareTo` method declared in the interface matches our existing operator already, so if you want to make `MyInt` a `Comparable`, all you need to add is the `override` keyword:

```kotlin
class MyInt(private val value: Int) : Comparable<MyInt> {
    // ...
    override operator fun compareTo(other: MyInt): Int {
        return this.value - other.value
    }
}
```

#### Assignments are not expressions

We've just looked at what `==` and `===` do, so this is a good place to take a closer look at the regular old `=` operator. In Java, assignments are *expressions* (something with a return type, which yields a return value when evaluated), and they return the freshly assigned value. This is why you can write code like this:

```java
BufferedReader reader = ...;
String line = null;
while ((line = reader.readLine()) != null) {
    System.out.println(line);
}
```

You might have noticed that we didn't do this in [chapter 7](./7.md), when we were reading lines from a file. In Kotlin, assignments are only *statements* (a valid line of code that can be executed), but not *expressions*. This language design decision follows the frequent advice of not using the return value of an assignment as an expression even if a language allows it, as this can be hard to read, and it's a potential source of bugs.

For example, this code in C is just a single character away from checking whether `x` is `0` and running a branch accordingly. Instead, it always sets `x` to `0` and then runs the `else` branch:

```c
if (x = 0) {
    // Run if X was zero...
} else {
    // Run if X is non-zero...
}
```

## Conventions

We've seen how basic operators work, let's move on to some more advanced ones, which we'll discuss under the theme of *conventions*. These conventions will define further, special operators, which will let you empower your own types, and make them play just as smoothly with built-in language features as first-party types do.

Our example for this section will be a `Time` class, which represents a time of day as hours and minutes, but stores just a single value internally:

```kotlin
class Time(hours: Int, minutes: Int)  {
    private val totalMinutes = hours * 60 + minutes

    val hours: Int
        get() = totalMinutes / 60
    val minutes: Int
        get() = totalMinutes % 60
}
```

Whenever `hours` or `minutes` are accessed, those values will be computed from `totalMinutes`.

The first convention we want to use is the *range* convention, to define a given interval of time. We already know that the `..` syntax can create a range of two `Int` values. This range can be iterated over, and we can also check if an `Int` is within the range:

```kotlin
val range = 0..10
for (i in range) { ... }
if (5 in range) { ... }
```

### Custom ranges

Let's do something similar for our `Time` class, step by step. If we look at the type of `range`, we'll see that it's an instance of an [`IntRange`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-int-range/index.html). Similarly, we'll create a `TimeRange` class that will represent our interval, between two points in time:

```kotlin
class TimeRange(private val start: Time, private val end: Time)
```

The `..` operator used to create a range maps to the `rangeTo` operator function, which we can define either as a member or an extension. We can go with an extension for this one - this way, the `Time` class can stay simpler, and we can add the range functionality to it without modifying it:

```kotlin
operator fun Time.rangeTo(other: Time): TimeRange {
    return TimeRange(this, other)
}
```

With this defined, we can already create a `TimeRange`:

```kotlin
val morning = Time(8, 0)
val evening = Time(17, 0)

val range: TimeRange = morning..evening
```

### Containment

Let's see how we can check if the range contains a given value. Whenever the `in` keyword is used, it will actually map to a call of an operator called `contains`, by convention. This method has to exist on whatever is on the right hand side of `in`, and it will receive the value on its left as its parameter. So `x in y` is equivalent to a `y.contains(x)` call.

We can implement this operator in our `TimeRange` with a small bit of arithmetic:

```kotlin
class TimeRange(private val start: Time, private val end: Time) {
    operator fun contains(time: Time): Boolean {
        val timeMinutes = time.hours * 60 + time.minutes
        return start.hours * 60 + start.minutes <= timeMinutes &&
                timeMinutes <= end.hours * 60 + end.minutes
    }
}
```

>This would be much, much simpler if we had a `compareTo` implementation for `Time` - write one!

Putting this new method to the test, we can see that we also get `!in` for free:

```kotlin
val lunch = Time(12, 30)
println(lunch in range) // true
println(lunch !in range) // false
```

### Iteration

Let's move on to iteration. When we use the `for (x in y)` syntax, we are again invoking functions under the hood. This syntax is equivalent to the following:

```kotlin
val iterator = y.iterator()
while (iterator.hasNext()) {
    val x = iterator.next()
    // for loop body for `x`
}
```

First, we'll need to create an operator method in `TimeRange` called `iterator`, which - as you might guess - has to return an [`Iterator`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterator/index.html):

```kotlin
class TimeRange(private val start: Time, private val end: Time) {
    // the `contains` implementation...
  
    operator fun iterator(): Iterator<Time> {
        TODO("implement")
    }
}
```

How do we provide an `Iterator`? We can implement the interface ourselves right here in the method, with an object expression. An `Iterator` has to define the two methods that you can see used in the pseudo-code snippet above:

- `hasNext()` returns a `Boolean`, and tells us whether there are any elements remaining,
- `next()` fetches the next element from whatever we're iterating.

Our iterator will iterate on time values minute by minute within our range. Here's our implementation:

```kotlin
operator fun iterator(): Iterator<Time> {
    return object : Iterator<Time> {
        // 1
        val startMinutes = start.hours * 60 + start.minutes
        val endMinutes = end.hours * 60 + end.minutes

        // 2
        var currentMinutes = startMinutes

        // 3
        override fun hasNext(): Boolean {
            return currentMinutes <= endMinutes
        }

        // 4
        override fun next(): Time {
            return Time(hours = currentMinutes / 60, minutes = currentMinutes % 60).also {
                currentMinutes++
            }
        }
    }
}
```

Here, we...

1. Calculate the start and end times of our range in total minutes.
2. Keep track of where our iteration is in a mutable property.
3. Say that there are more time instances to iterate through as long as the current value didn't pass the max value.
4. Create a new `Time` instance every time the iterator is asked for the next item.

>We didn't add a check for whether we still have elements in the `next` method. This isn't an issue when our range is used in a loop, but it could cause issues if the iterator is used manually, through function calls. Our Kotlin `Iterator` maps to [`java.util.Iterator`](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html#next--), which specifies that `next` should throw a `NoSuchElementException` if there are no more elements to return.

Note that we are at no point storing all the `Time` instances between the min and max values of the range (neither does `IntRange`). We are just lazily creating these intermediate values, as the `for` loop is progressing on our range.

>Again, this code could be simpler if we had a `compareTo` and an `increment` operator in our `Time` class. Write those operators, and then refactor this code!

Let's put our iteration code to work:

```kotlin
for (time in morning..lunch) {
    println(String.format("%02d:%02d", time.hours, time.minutes))
}
```

>Kotlin doesn't offer its own string formatting syntax at this time. However, as long as we're on the JVM, we can make use of the same format strings that Java offers.

Very similarly to `compareTo` and `Comparable`, you can optionally implement an interface called [`Iterable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/index.html), which declares the `iterator` method with a matching signature to the operator. Implementing this interface is *very* powerful. It will grant you access to many of the extensions of the Kotlin Standard Library's collection API, as most of these are defined on `Iterable`.

For example, you could take a `TimeRange`, and quickly get a `List<Time>` that only contains the instances of `Time` from it that are at a round 15 minutes:

```kotlin
(morning..lunch).filter { it.minutes % 15 == 0 }
```

So the general takeaway from these optional interfaces:

- If you define the right operators, then by convention, you get to use your own types with certain language features.
- If you implement these interfaces, you'll also get access to a vast number of extensions that are defined on those interfaces.

>The operators that enable conventions can be added as extensions, so you can make existing types that you don't own comparable with `>` or iterable with `in`. However, you can't make types implement interfaces after-the-fact.

### Range utilities

The built-in range types are also `Iterable`. This means that you can, for exampe, use `forEach` on them to run some code for a certain range of indices:

```kotlin
(10..20).forEach {
    println(it)
}
```

A method reference could clean this up even further:

```kotlin
(10..20).forEach(::println)
```

Similarly, the `map` extension can also come in handy, to create a number of instances of some type, based on the indices:

```kotlin
val times = (5..15).map { min -> Time(8, min) }
```

### Destructuring

One last convention we can apply here is destructuring. We know that data classes, and even lists can be destructured. But this feature, again, seems like something deeply baked into the language, with strong integration in basic types. Thankfully, destructuring also works through operator conventions!

For each index that you want to be able to destructure, you have to define a method with a corresponding name: `component1`, `component2`, and so on. For our `Time` class, we can define these methods even as extensions, to be able to destructure it into an hour and a minute value:

```kotlin
operator fun Time.component1(): Int = hours
operator fun Time.component2(): Int = minutes
```

We can now update our previous loop with destructuring:

```kotlin
for ((hours, minutes) in morning..lunch) {
    println(String.format("%02d:%02d", hours, minutes))
}
```

Note the power that lies in component accessors being methods. They aren't restricted to returning values stored in the class, as-is. They can compute values on-the-fly, return values with different types, and so on. Anything that a function can do can be done when a component is being accessed during destructuring.

### Performance of built-in ranges

Based on what we've just seen, we know that code like this:

```kotlin
for (i in 0..10) {
    println(i)
}
```

... will create an `IntRange` instance, and then get an `Iterator` on it, which it uses to run the `for` loop. This is multiple allocations and several allocations, while the Java equivalent of this loop has none:

```java
for (int i = 0; i <= 10; i++) {
    System.out.println(i);
}
```

If we decompile the bytecode generated from the Kotlin loop above, we can be relieved:

```java
int i = 0;
for(byte var11 = 10; i <= var11; ++i) {
   System.out.println(i);
}
```

Simple usages of the built-in ranges are recognized and optimized by the compiler, so that no unnecessary allocations occur. If you assign an `IntRange` to a variable, and pass it around as a parameter, that *will* result in an actual object allocation, as something has to be passed around.

## Delegates

We've just uncovered the inner workings of operators and ranges, and seen that we can do everything the built-in types could do for our own types as well. It's time to do the same thing for property delegates. We've looked at the built-in ones provided by the Standard Library earlier, and we'll now see that there's actually nothing special about them.

### Implementing `lazy`

In fact, let's start by reimplementing one of them, the [lazy](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html) delegate. Recall the example we used earlier, of computing the value of `pi` lazily? The `lazy` delegate let us only perform the computation when we first access the value of `pi`, and then it stored its value for us, so that any subsequent calls to the property were quick.

```kotlin
val pi by lazy {
    print("Computing... ")
    sqrt(6 * (1..1_000_000_000).sumByDouble {
        1.toDouble() / it / it
    })
}

println(pi) // Computing... 3.14159264498239
println(pi) // 3.14159264498239
println(pi) // 3.14159264498239
```

So how do delegates work? They extract the logic of a property's getter (and setter, if the property isn't a read-only `val`) into a class. For a class to be eligible for use as a delegate that backs a property, it needs to define a specific operator function, which will be called whenever the value of the property it backs is being read. This, again defined by convention, is the following `getValue` function:

```kotlin
class Lazy<T> {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): T {
        TODO("implement getter")
    }
}
```

We've created a class called `Lazy` with a generic parameter (`T`), which will be the type of the value that it computes lazily. The `getValue` function has to have two very specific parameters, we'll explore these later. What we need to care about for now is its return type, which is up to us do define - we'll choose the `T` type here, so that this class can back a property of that type.

We've worked with the backing field using the `field` identifier in custom getters and setters already, but we don't get this kind of a field when using delegates, as how we implement the getter and setter is completely up to us.
 
 So if we want to store a value, we'll simply declare a property in our delegate class. We'll also add a constructor parameter to our delegate: the function (usually a lambda) that can compute the value of the property when needed.

```kotlin
class Lazy<T>(private val initializer: () -> T) {
    private var value: T? = null

    operator fun getValue(thisRef: Any?, property: KProperty<*>): T {
        if (value == null) {
            value = initializer()
        }
        return value!!
    }
}
```

Inside the `getValue` function, we check if our `value` property is already storing a value, and if it isn't, we initialize it using the `initializer` function provided. Then, we return the stored value.

Here's what the usage of this delegate would look like:

```kotlin
val pi by Lazy({
    println("Computing")
    sqrt(6 * (1..1_000_000_000).sumByDouble {
        1.toDouble() / it / it
    })
})
```

Of course, we can drop the parentheses around the lambda that we're passing in to the constructor, to get closer to the original syntax. We also want to have a lowercase `lazy` there, which we *could* achieve by renaming the class... Or we can do what the Standard Library does, and introduce a factory function for our delegate instead:

```kotlin
fun <T> lazy(initializer: () -> T) = Lazy(initializer)
```

This gets us back to the original syntax at the use site:

```kotlin
val pi by lazy {
    println("Computing")
    sqrt(6 * (1..1_000_000_000).sumByDouble {
        1.toDouble() / it / it
    })
}
```

### Standard Library delegate interfaces

Implementing `lazy` was a bit difficult, as we had to get the signature of `getValue` just right, off the top of our head (or at least by going to the documentation, and copying it from there). Thankfully, there's a better way: the Standard Library provides a pair of interfaces for delegates, the first one being [`ReadOnlyProperty`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-read-only-property/index.html), which you can use when implementing delegates that will only ever be used as a `val`.

```kotlin
public interface ReadOnlyProperty<in R, out T> {
    public operator fun getValue(thisRef: R, property: KProperty<*>): T
}
```

The second generic parameter, `T`, is used the same way as we've just used it: it corresponds to the type of the property that's being delegated, and therefore, the return type of the `getValue` is defined as `T`.

`R` is a more interesting type parameter in the delegate interfaces, which is being used as the type of the `thisRef` parameter. The name `thisRef` is quite descriptive. Whenever `getValue` is called, this first parameter will be a `this`-reference, i.e. the reference of the instance that contains this property (or `null`, if the property doesn't belong to a class instance, which can happen if it's top level or local). If you use a parameter that's more concrete than `Any`, *you can restrict the types of classes that the delegate can be used in*.

>Note that if you don't make this parameter nullable, your delegate will not be available for use in top level or local declarations.

Receiving this containing instance as a parameter means that you can access its state or methods while you're performing your getter's tasks, which can be a powerful tool to have. For example, on Android, restricting this `R` parameter to [`Context`](https://developer.android.com/reference/android/content/Context), the class which allows access to system resources, is a popular design choice.

We can update our `Lazy` delegate to use this interface:

```kotlin
class Lazy<T>(private val initializer: () -> T) : ReadOnlyProperty<Any?, T> {
    private var value: T? = null

    override operator fun getValue(thisRef: Any?, property: KProperty<*>): T {
        if (value == null) {
            value = initializer()
        }
        return value!!
    }
}
```

Thanks to this interface, we can also hide this concrete class from clients, by using the interface as the return type of the `lazy` factory function:

```kotlin
fun <T> lazy(initializer: () -> T): ReadOnlyProperty<Any?, T> = Lazy(initializer)
```

>With the implementation of `lazy` as a starting point, try reimplementing [`Delegates.observable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html) and [`Delegates.vetoable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable.html) as practice!

### Implementing `PersistentString`

The second interface, [`ReadWriteProperty`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-read-write-property/index.html) can be used for properties that are either read-only (`val`) or read-write (`var`), and it also has a `setValue` method. This method takes a `T` as its last parameter, and returns `Unit`.

```kotlin
public interface ReadWriteProperty<in R, T> {
    public operator fun getValue(thisRef: R, property: KProperty<*>): T
    public operator fun setValue(thisRef: R, property: KProperty<*>, value: T)
}
```

Let's implement another delegate, using this read-write interface. We'll create a `PersistentString` delegate, which will store a `String` value on disk, transparently. We'll implement the interface above, and in each method, use the `string.txt` file to store our value.

```kotlin
class PersistentString : ReadWriteProperty<Any?, String> {
    override operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        val file = File("string.txt")
        if (file.exists()) {
            return file.readText()
        }
        return ""
    }

    override operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        val file = File("string.txt")
        file.writeText(value)
    }
}
```

Let's add a factory function for this delegate, too:

```kotlin
fun persistentString(): ReadWriteProperty<Any?, String> = PersistentString()
```

This is a working implementation, that can store our `String` value persistently:

```kotlin
// first run
var str by persistentString()
println(str) // ""
str = "hello"

// next run of the application...
var str by persistentString()
println(str) // "hello"
```

There's the issue of this `PersistentString` operating on a single, hardcoded file. What if we want to use multiple persisted `String` properties simultaneously? We could introduce a constructor parameter to the delegate class, where the filename could be provided. We can do one better: use the name of the property as the filename!

Here's where the second parameter of the getter and setter functions comes into play. This parameter is named `property`, and has the type of [`KProperty`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/index.html).

Java has reflection facilities such as the [`java.lang.Class`](https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html) and [`java.lang.reflect.Method`](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html) types, which are a meta representation of classes and methods, respectively. These types let you inspect the structure of classes dynamically, at runtime.

Kotlin comes with its own suite of reflection related features and types, and the `KProperty` type is one of these. It's a meta representation of the property that's being delegated, and contains information about it such as whether it's a `const`, whether it's `lateinit`, what annotations are on it, or what its name is - which is just what we need!.

Inside each of our methods, we can use `property.name` to get the name of the property:

```kotlin
override operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
    val file = File("${property.name}.txt")
    /* ... */
}
```

With the client code above, this would make our property use the `str.txt` file as its storage.

Reading the value of this `String` from a file every time it's accessed within a single run of the application is expensive. We can upgrade our class with a property that acts as a read cache for the `String` in memory.

How do we initialize this property? We could make it nullable, and perform lazy initialization on it in `getValue`:

```kotlin
class PersistentString : ReadWriteProperty<Any?, String> {
    private var cachedValue: String? = null

    override operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        if (cachedValue == null) {
            val file = File("${property.name}.txt")
            cachedValue = if (file.exists()) file.readText() else ""
        }
        return cachedValue!!
    }

    override operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        cachedValue = value
        val file = File("${property.name}.txt")
        file.writeText(value)
    }
}
```

But what if we wanted to initialize this value when the delegate is created? The problem here is that the `property` parameter wouldn't be available for us in an initializer - we only get it when the getter or setter is invoked.

```kotlin
class PersistentString() : ReadWriteProperty<Any?, String> {
    private var cachedValue: String
    
    init {
        val file = File("${property.name}.txt") // e: Unresolved reference: property
        cachedValue = if (file.exists()) file.readText() else ""
    }
    
    // ...
}
```

### The `provideDelegate` function

Here's where `provideDelegate` comes into play. This is a third operator you can make use of when creating your own delegates, and it allows you to define factory classes for your delegates.

For our troubles with `PersistedString`, we can create a `PersistentStringFactory` that will be tasked with creating our delegates. The `provideDelegate` function, just like the previous two, has a well-defined signature by convention - the parameters of which you'll already be familiar with: it receives the `thisRef` and `property` parameters, and can use these to create a `ReadWriteProperty`:

```kotlin
object PersistentStringFactory {
    operator fun provideDelegate(
            thisRef: Any?,
            property: KProperty<*>
    ): ReadWriteProperty<Any?, String> {
        return PersistentString(property.name)
    }
}
```

The `PersistentString` class has to be updated at this point, to receive the key to use as a parameter, but that's easy enough:

```kotlin
class PersistentString(private val key: String) : ReadWriteProperty<Any?, String> {
    private var cachedValue: String

    init {
        cachedValue = File("${key}.txt")
                .takeIf { it.exists() }
                ?.readText()
                ?: ""
    }

    override operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        return cachedValue
    }
    
    // ...
}
```

>Note the way we've refactored the initializer to a more functional code style, using [`takeIf`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/take-if.html) to convert the question of whether the file exists into a question of nullability.

How do we use this factory? We just delegate to it, as if it was the delegate instance backing our property. The compiler will then prompt the factory to create a delegate instance, and forward any accessor calls to that instance.

One interesting drawback here is that you *have to* expose this factory type to the outside world, you can't hide it behind an interface - the `provideDelegate` method is not defined in an interface, like the others. That means that the `persistentString` factory function now has to return this factory type instead of a `ReadWriteProperty`:

```kotlin
fun persistentString(): PersistentStringFactory = PersistentStringFactory
```

>You could still define your own interface for this, and call it, say, `DelegateFactory`.

The use site of `persistentString` remains the same, we just delegate the property to whatever object the function returns, which is now the single factory instance:

```kotlin
// first run
var str by persistentString()
println(str) // ""
str = "hello"
 
// next run of the application...
var str by persistentString()
println(str) // "hello"
```

Introducing this factory also lets us fix a bug that we've introduced by caching our value inside the delegate. With the current implementation, if multiple strings with the same name are declared, only the one that a write was performed through will have its cached value updated, while the rest will hold outdated values in memory. They won't read from file after the initialization, because it's assumed that the value in the file only changes when their setter is invoked.

This factory gives us control over the `PersistentString` instances being created, and we can ensure that only a single one of them exists for each name:

```kotlin
object PersistentStringFactory {
    private val keys = mutableSetOf<String>()

    operator fun provideDelegate(
            thisRef: Any?,
            prop: KProperty<*>
    ): ReadWriteProperty<Any?, String> {
        require(prop.name !in keys) { "No duplicates allowed in PersistentStrings" }
        keys += prop.name
        return PersistentString(prop.name)
    }
}
```

### Map delegates in the Standard Library

Finally, to wrap up the topic of delegates, let's talk about a feature of the Standard Library: delegation to `Map` instances. The `Map` type of course knows nothing about delegates, but there are [`setValue`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/set-value.html) and [`getValue`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/get-value.html) operators defined for it as extensions.

>At this point, the interfaces being optional in order for the delegation conventions to work comes in really handy. You wouldn't be able to make `Map` implement an interface, but you can add operators to it as extension functions.

How does delegation to a `Map` work? For example, we can set up a class that holds all of its data in a `Map` that it receives as a parameter:

```kotlin
class Address(map: MutableMap<String, String>) {
    var country: String by map
    var zip: String by map
    var city: String by map
    var street: String by map
}
```

Each of these properties will be stored in the map, with the name of the property being used as the key (using the `property` parameter of the accessors that we've seen above).

```kotlin
val map = mutableMapOf<String, String>()
val address = Address(map)
address.country = "Hungary"
address.city = "Budapest"
address.zip = "1117"

println(address.city) // Budapest
```

Storing values works as expected. And if you were to print the entire contents of the `map` instance, you'd see this:

```
{country=Hungary, city=Budapest, zip=1117}
```

# Summary

Kotlin offers many convenient features for its first-party types: various kinds of operators, integration with language features such as iteration with the `for` loop or use in destructuring, and more. The delegates of the Standard Library are also similarly tightly integrated, seemingly magical parts of the language.

All of these things, however, are available for anyone to use, by implementing the right operators and aligning with certain conventions. This enables your own types to be just as idiomatic and convenient to use as any built-in type. You can also improve the API of existing types, by adding these conventions to them as extensions.

# Sources

- [Delightful Delegate Design](https://blog.autsoft.hu/delightful-delegate-design/)
- Official documentation
    - [Operator overloading](https://kotlinlang.org/docs/reference/operator-overloading.html)
    - [Ranges and Progressions](https://kotlinlang.org/docs/reference/ranges.html)
    - [Delegated Properties](https://kotlinlang.org/docs/reference/delegated-properties.html) 
